<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Testing &amp; Documentation - Rust Course 2025</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Interactive Rust programming course built with mdBook">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Course 2025</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18/edit/main/mdbook/src/day3/13_testing.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-13-testing--documentation"><a class="header" href="#chapter-13-testing--documentation">Chapter 13: Testing &amp; Documentation</a></h1>
<h2 id="building-robust-rust-applications-with-comprehensive-testing"><a class="header" href="#building-robust-rust-applications-with-comprehensive-testing">Building Robust Rust Applications with Comprehensive Testing</a></h2>
<h3 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h3>
<p>By the end of this chapter, you’ll be able to:</p>
<ul>
<li>Write comprehensive unit tests, integration tests, and documentation tests</li>
<li>Use test-driven development (TDD) effectively in Rust</li>
<li>Mock complex dependencies using traits</li>
<li>Structure projects for maximum testability</li>
<li>Generate and maintain excellent documentation</li>
<li>Apply testing strategies to embedded systems (when needed)</li>
<li>Debug test failures efficiently</li>
<li>Measure and improve test coverage</li>
</ul>
<hr />
<h2 id="testing-in-rust-the-foundation-of-reliable-software"><a class="header" href="#testing-in-rust-the-foundation-of-reliable-software">Testing in Rust: The Foundation of Reliable Software</a></h2>
<h3 id="why-testing-matters"><a class="header" href="#why-testing-matters">Why Testing Matters</a></h3>
<p>Testing is crucial for building reliable software, and Rust’s testing framework makes it both easy and powerful. Let’s start with the basics and work up to more complex scenarios.</p>
<p><strong>Testing Comparison Across Languages:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>C/C++</th><th>C#/Java</th><th>Python</th><th>Rust</th></tr></thead><tbody>
<tr><td>Built-in framework</td><td>No</td><td>Yes</td><td>Yes</td><td><strong>Yes + Zero-cost</strong></td></tr>
<tr><td>Mocking</td><td>Third-party</td><td>Frameworks</td><td>Built-in</td><td><strong>Trait-based</strong></td></tr>
<tr><td>Documentation tests</td><td>No</td><td>Limited</td><td>doctest</td><td><strong>Integrated</strong></td></tr>
<tr><td>Compile-time checks</td><td>Limited</td><td>Some</td><td>None</td><td><strong>Extensive</strong></td></tr>
<tr><td>Performance testing</td><td>Manual</td><td>Frameworks</td><td>Third-party</td><td><strong>Built-in</strong></td></tr>
</tbody></table>
</div>
<h3 id="basic-unit-testing"><a class="header" href="#basic-unit-testing">Basic Unit Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple function to test temperature conversions
pub fn celsius_to_fahrenheit(celsius: f32) -&gt; f32 {
    celsius * 9.0 / 5.0 + 32.0
}

pub fn fahrenheit_to_celsius(fahrenheit: f32) -&gt; f32 {
    (fahrenheit - 32.0) * 5.0 / 9.0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_celsius_to_fahrenheit() {
        assert_eq!(celsius_to_fahrenheit(0.0), 32.0);
        assert_eq!(celsius_to_fahrenheit(100.0), 212.0);
        assert!((celsius_to_fahrenheit(20.0) - 68.0).abs() &lt; 0.001);
    }

    #[test]
    fn test_fahrenheit_to_celsius() {
        assert_eq!(fahrenheit_to_celsius(32.0), 0.0);
        assert_eq!(fahrenheit_to_celsius(212.0), 100.0);
        assert!((fahrenheit_to_celsius(68.0) - 20.0).abs() &lt; 0.001);
    }

    #[test]
    fn test_conversion_roundtrip() {
        let temps = vec![0.0, 25.0, -40.0, 100.0];
        for temp in temps {
            let converted = fahrenheit_to_celsius(celsius_to_fahrenheit(temp));
            assert!((converted - temp).abs() &lt; 0.001,
                    "Roundtrip failed for {}: got {}", temp, converted);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="trait-based-testing-and-mocking"><a class="header" href="#trait-based-testing-and-mocking">Trait-Based Testing and Mocking</a></h2>
<p>One of Rust’s greatest strengths is using traits to create testable abstractions. This allows us to test complex logic without depending on external systems.</p>
<h3 id="the-power-of-trait-abstraction"><a class="header" href="#the-power-of-trait-abstraction">The Power of Trait Abstraction</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

// Our core Temperature type
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Temperature {
    pub celsius: f32,
}

impl Temperature {
    pub fn new(celsius: f32) -&gt; Self {
        Self { celsius }
    }

    pub fn from_fahrenheit(fahrenheit: f32) -&gt; Self {
        Self {
            celsius: (fahrenheit - 32.0) * 5.0 / 9.0,
        }
    }
}

impl fmt::Display for Temperature {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "{:.1}°C", self.celsius)
    }
}

// Trait that abstracts temperature reading
pub trait TemperatureSensor {
    type Error: fmt::Debug;

    fn read_temperature(&amp;mut self) -&gt; Result&lt;Temperature, Self::Error&gt;;
    fn sensor_id(&amp;self) -&gt; &amp;str;
}

// Mock implementation for testing
pub struct MockTemperatureSensor {
    id: String,
    temperature: f32,
    fail_next: bool,
    offline: bool,
}

impl MockTemperatureSensor {
    pub fn new(id: String, temperature: f32) -&gt; Self {
        Self {
            id,
            temperature,
            fail_next: false,
            offline: false,
        }
    }

    pub fn set_temperature(&amp;mut self, temp: f32) {
        self.temperature = temp;
    }

    pub fn set_offline(&amp;mut self, offline: bool) {
        self.offline = offline;
    }

    pub fn fail_next_read(&amp;mut self) {
        self.fail_next = true;
    }
}

#[derive(Debug)]
pub enum MockError {
    SensorOffline,
    ReadFailed,
}

impl TemperatureSensor for MockTemperatureSensor {
    type Error = MockError;

    fn read_temperature(&amp;mut self) -&gt; Result&lt;Temperature, Self::Error&gt; {
        if self.offline {
            return Err(MockError::SensorOffline);
        }

        if self.fail_next {
            self.fail_next = false;
            return Err(MockError::ReadFailed);
        }

        Ok(Temperature::new(self.temperature))
    }

    fn sensor_id(&amp;self) -&gt; &amp;str {
        &amp;self.id
    }
}

#[cfg(test)]
mod sensor_tests {
    use super::*;

    #[test]
    fn mock_sensor_works() {
        let mut sensor = MockTemperatureSensor::new("test-sensor".to_string(), 25.0);

        let reading = sensor.read_temperature().unwrap();
        assert_eq!(reading.celsius, 25.0);
        assert_eq!(sensor.sensor_id(), "test-sensor");
    }

    #[test]
    fn mock_sensor_can_fail() {
        let mut sensor = MockTemperatureSensor::new("test-sensor".to_string(), 25.0);

        sensor.fail_next_read();
        let result = sensor.read_temperature();
        assert!(matches!(result, Err(MockError::ReadFailed)));

        // Should work again after failure
        let reading = sensor.read_temperature().unwrap();
        assert_eq!(reading.celsius, 25.0);
    }

    #[test]
    fn mock_sensor_can_be_offline() {
        let mut sensor = MockTemperatureSensor::new("test-sensor".to_string(), 25.0);

        sensor.set_offline(true);
        let result = sensor.read_temperature();
        assert!(matches!(result, Err(MockError::SensorOffline)));

        sensor.set_offline(false);
        let reading = sensor.read_temperature().unwrap();
        assert_eq!(reading.celsius, 25.0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-organization-and-best-practices"><a class="header" href="#test-organization-and-best-practices">Test Organization and Best Practices</a></h2>
<h3 id="test-module-organization"><a class="header" href="#test-module-organization">Test Module Organization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In your lib.rs or main module
pub mod temperature {
    pub use crate::{Temperature, TemperatureSensor, MockTemperatureSensor};

    // Business logic that uses the sensor
    pub struct TemperatureMonitor&lt;S: TemperatureSensor&gt; {
        sensor: S,
        alert_threshold: Temperature,
    }

    impl&lt;S: TemperatureSensor&gt; TemperatureMonitor&lt;S&gt; {
        pub fn new(sensor: S, threshold_celsius: f32) -&gt; Self {
            Self {
                sensor,
                alert_threshold: Temperature::new(threshold_celsius),
            }
        }

        pub fn check_temperature(&amp;mut self) -&gt; Result&lt;bool, S::Error&gt; {
            let current = self.sensor.read_temperature()?;
            Ok(current.celsius &gt; self.alert_threshold.celsius)
        }

        pub fn get_sensor_id(&amp;self) -&gt; &amp;str {
            self.sensor.sensor_id()
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::{MockTemperatureSensor, MockError};

        #[test]
        fn monitor_detects_high_temperature() {
            let sensor = MockTemperatureSensor::new("test".to_string(), 30.0);
            let mut monitor = TemperatureMonitor::new(sensor, 25.0);

            let is_alert = monitor.check_temperature().unwrap();
            assert!(is_alert);
        }

        #[test]
        fn monitor_handles_normal_temperature() {
            let sensor = MockTemperatureSensor::new("test".to_string(), 20.0);
            let mut monitor = TemperatureMonitor::new(sensor, 25.0);

            let is_alert = monitor.check_temperature().unwrap();
            assert!(!is_alert);
        }

        #[test]
        fn monitor_propagates_sensor_errors() {
            let mut sensor = MockTemperatureSensor::new("test".to_string(), 20.0);
            sensor.fail_next_read();
            let mut monitor = TemperatureMonitor::new(sensor, 25.0);

            let result = monitor.check_temperature();
            assert!(matches!(result, Err(MockError::ReadFailed)));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<p>Integration tests go in the <code>tests/</code> directory and test your crate from the outside:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/temperature_integration.rs
use your_crate::{Temperature, TemperatureSensor, MockTemperatureSensor};
use your_crate::temperature::TemperatureMonitor;

#[test]
fn full_temperature_monitoring_workflow() {
    let mut sensor = MockTemperatureSensor::new("integration-test".to_string(), 15.0);
    let mut monitor = TemperatureMonitor::new(sensor, 20.0);

    // Initially, temperature is below threshold
    assert!(!monitor.check_temperature().unwrap());

    // Simulate temperature rise
    // Note: We can't modify the sensor after moving it into monitor
    // This is where the real hardware implementation would change

    // In a real scenario, you might have:
    // - A sensor that reads from actual hardware
    // - A monitor that runs in a loop
    // - Integration with real systems
}
<span class="boring">}</span></code></pre></pre>
<h2 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation Tests</a></h2>
<p>Rust can run code examples in your documentation as tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Convert Celsius to Fahrenheit
///
/// # Examples
///
/// ```
/// use your_crate::Temperature;
///
/// let temp = Temperature::new(20.0);
/// assert!((temp.to_fahrenheit() - 68.0).abs() &lt; 0.1);
/// ```
///
/// # Conversion Formula
///
/// The formula is: F = C × 9/5 + 32
///
/// ```
/// use your_crate::Temperature;
///
/// // Freezing point of water
/// assert_eq!(Temperature::new(0.0).to_fahrenheit(), 32.0);
///
/// // Boiling point of water
/// assert_eq!(Temperature::new(100.0).to_fahrenheit(), 212.0);
/// ```
impl Temperature {
    pub fn to_fahrenheit(&amp;self) -&gt; f32 {
        self.celsius * 9.0 / 5.0 + 32.0
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Run documentation tests with:</p>
<pre><code class="language-bash">cargo test --doc
</code></pre>
<h2 id="test-driven-development-tdd-in-rust"><a class="header" href="#test-driven-development-tdd-in-rust">Test-Driven Development (TDD) in Rust</a></h2>
<p>TDD follows the Red-Green-Refactor cycle:</p>
<ol>
<li><strong>Red</strong>: Write a failing test</li>
<li><strong>Green</strong>: Write minimal code to make it pass</li>
<li><strong>Refactor</strong>: Improve the code while keeping tests passing</li>
</ol>
<h3 id="tdd-example-temperature-statistics"><a class="header" href="#tdd-example-temperature-statistics">TDD Example: Temperature Statistics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Step 1: Write the test first (RED)
#[cfg(test)]
mod stats_tests {
    use super::*;

    #[test]
    fn temperature_stats_calculates_average() {
        let temps = vec![
            Temperature::new(10.0),
            Temperature::new(20.0),
            Temperature::new(30.0),
        ];

        let stats = TemperatureStats::from_readings(&amp;temps);

        assert_eq!(stats.average().celsius, 20.0);
        assert_eq!(stats.min().celsius, 10.0);
        assert_eq!(stats.max().celsius, 30.0);
        assert_eq!(stats.count(), 3);
    }

    #[test]
    fn temperature_stats_handles_empty_list() {
        let temps = vec![];

        let result = TemperatureStats::from_readings(&amp;temps);

        assert!(result.is_none());
    }
}

// Step 2: Write minimal implementation (GREEN)
pub struct TemperatureStats {
    min: Temperature,
    max: Temperature,
    average: Temperature,
    count: usize,
}

impl TemperatureStats {
    pub fn from_readings(readings: &amp;[Temperature]) -&gt; Option&lt;Self&gt; {
        if readings.is_empty() {
            return None;
        }

        let mut min_temp = readings[0].celsius;
        let mut max_temp = readings[0].celsius;
        let mut sum = 0.0;

        for reading in readings {
            let temp = reading.celsius;
            if temp &lt; min_temp {
                min_temp = temp;
            }
            if temp &gt; max_temp {
                max_temp = temp;
            }
            sum += temp;
        }

        let average = sum / readings.len() as f32;

        Some(Self {
            min: Temperature::new(min_temp),
            max: Temperature::new(max_temp),
            average: Temperature::new(average),
            count: readings.len(),
        })
    }

    pub fn min(&amp;self) -&gt; Temperature { self.min }
    pub fn max(&amp;self) -&gt; Temperature { self.max }
    pub fn average(&amp;self) -&gt; Temperature { self.average }
    pub fn count(&amp;self) -&gt; usize { self.count }
}

// Step 3: Refactor as needed while tests still pass
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-testing-techniques"><a class="header" href="#advanced-testing-techniques">Advanced Testing Techniques</a></h2>
<h3 id="property-based-testing-with-proptest"><a class="header" href="#property-based-testing-with-proptest">Property-Based Testing with <code>proptest</code></a></h3>
<pre><code class="language-toml">[dev-dependencies]
proptest = "1.0"
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod property_tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn temperature_conversion_roundtrip(celsius in -273.15f32..1000.0f32) {
            let temp = Temperature::new(celsius);
            let fahrenheit = temp.to_fahrenheit();
            let back_to_celsius = Temperature::from_fahrenheit(fahrenheit);

            prop_assert!((back_to_celsius.celsius - celsius).abs() &lt; 0.001);
        }

        #[test]
        fn temperature_display_never_panics(celsius in f32::NEG_INFINITY..f32::INFINITY) {
            if celsius.is_finite() {
                let temp = Temperature::new(celsius);
                let _ = format!("{}", temp); // Should never panic
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="benchmark-testing"><a class="header" href="#benchmark-testing">Benchmark Testing</a></h3>
<pre><code class="language-toml">[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "temperature_bench"
harness = false
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// benches/temperature_bench.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use your_crate::Temperature;

fn bench_temperature_conversion(c: &amp;mut Criterion) {
    c.bench_function("celsius_to_fahrenheit", |b| {
        b.iter(|| {
            let temp = Temperature::new(black_box(25.0));
            black_box(temp.to_fahrenheit())
        })
    });
}

criterion_group!(benches, bench_temperature_conversion);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<h2 id="embedded-testing-considerations"><a class="header" href="#embedded-testing-considerations">Embedded Testing Considerations</a></h2>
<p>When your code needs to run on embedded systems:</p>
<h3 id="testing-with-no_std"><a class="header" href="#testing-with-no_std">Testing with <code>no_std</code></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(test), no_std)]

<span class="boring">fn main() {
</span>// Use heapless collections instead of std
use heapless::Vec;

pub struct EmbeddedTemperatureBuffer&lt;const N: usize&gt; {
    readings: Vec&lt;Temperature, N&gt;,
}

impl&lt;const N: usize&gt; EmbeddedTemperatureBuffer&lt;N&gt; {
    pub fn new() -&gt; Self {
        Self {
            readings: Vec::new(),
        }
    }

    pub fn add_reading(&amp;mut self, temp: Temperature) -&gt; Result&lt;(), ()&gt; {
        self.readings.push(temp).map_err(|_| ())
    }

    pub fn calculate_average(&amp;self) -&gt; Option&lt;Temperature&gt; {
        if self.readings.is_empty() {
            return None;
        }

        let sum: f32 = self.readings.iter().map(|t| t.celsius).sum();
        Some(Temperature::new(sum / self.readings.len() as f32))
    }
}

#[cfg(test)]
mod embedded_tests {
    use super::*;

    #[test]
    fn embedded_buffer_works() {
        let mut buffer: EmbeddedTemperatureBuffer&lt;3&gt; = EmbeddedTemperatureBuffer::new();

        buffer.add_reading(Temperature::new(10.0)).unwrap();
        buffer.add_reading(Temperature::new(20.0)).unwrap();
        buffer.add_reading(Temperature::new(30.0)).unwrap();

        let avg = buffer.calculate_average().unwrap();
        assert_eq!(avg.celsius, 20.0);

        // Buffer is full - this should fail
        assert!(buffer.add_reading(Temperature::new(40.0)).is_err());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-complete-the-temperature-monitoring-system"><a class="header" href="#exercise-complete-the-temperature-monitoring-system">Exercise: Complete the Temperature Monitoring System</a></h2>
<p>Now it’s time to build the first increment of our capstone project!</p>
<h3 id="your-task"><a class="header" href="#your-task">Your Task</a></h3>
<ol>
<li>
<p>Create a new Rust project: <code>cargo new temp_core --lib</code></p>
</li>
<li>
<p>Implement the <code>Temperature</code> struct with conversion methods:</p>
<ul>
<li><code>new(celsius: f32) -&gt; Self</code></li>
<li><code>from_fahrenheit(fahrenheit: f32) -&gt; Self</code></li>
<li><code>from_kelvin(kelvin: f32) -&gt; Self</code></li>
<li><code>to_fahrenheit(&amp;self) -&gt; f32</code></li>
<li><code>to_kelvin(&amp;self) -&gt; f32</code></li>
</ul>
</li>
<li>
<p>Create a <code>TemperatureSensor</code> trait with:</p>
<ul>
<li><code>read_temperature(&amp;mut self) -&gt; Result&lt;Temperature, Self::Error&gt;</code></li>
<li><code>sensor_id(&amp;self) -&gt; &amp;str</code></li>
</ul>
</li>
<li>
<p>Implement a <code>MockTemperatureSensor</code> for testing that can:</p>
<ul>
<li>Return configurable temperatures</li>
<li>Simulate sensor failures</li>
<li>Go offline/online</li>
</ul>
</li>
<li>
<p>Write comprehensive tests covering:</p>
<ul>
<li>All temperature conversions</li>
<li>Mock sensor behavior</li>
<li>Error conditions</li>
<li>Edge cases (like very hot/cold temperatures)</li>
</ul>
</li>
</ol>
<h3 id="extension-challenges"><a class="header" href="#extension-challenges">Extension Challenges</a></h3>
<ol>
<li><strong>Property-Based Tests</strong>: Use <code>proptest</code> to verify conversion roundtrips</li>
<li><strong>Documentation Tests</strong>: Add examples to your documentation</li>
<li><strong>Benchmarks</strong>: Measure conversion performance</li>
<li><strong>no_std Support</strong>: Make your types work without the standard library</li>
</ol>
<h3 id="success-criteria"><a class="header" href="#success-criteria">Success Criteria</a></h3>
<ul>
<li>All tests pass: <code>cargo test</code></li>
<li>No warnings: <code>cargo clippy</code></li>
<li>Good documentation: <code>cargo doc --open</code></li>
<li>Code coverage is high</li>
<li>You can create mock sensors that behave predictably</li>
</ul>
<p>This foundation will be essential as we build more complex features in the following chapters!</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>✅ <strong>Testing is built into Rust</strong> - Use <code>#[test]</code>, <code>#[cfg(test)]</code>, and <code>cargo test</code></p>
<p>✅ <strong>Traits enable powerful mocking</strong> - Abstract dependencies behind traits</p>
<p>✅ <strong>Documentation tests keep examples current</strong> - Code in docs is tested automatically</p>
<p>✅ <strong>TDD helps design better APIs</strong> - Write tests first to drive good interfaces</p>
<p>✅ <strong>Integration tests verify real workflows</strong> - Test from the outside in</p>
<p>✅ <strong>Property tests catch edge cases</strong> - Generate random inputs to find bugs</p>
<p>✅ <strong>Embedded testing is possible</strong> - Use <code>no_std</code> compatible patterns</p>
<p>The testing foundation you build today will make every subsequent feature more reliable and maintainable!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day2/10_error_handling.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day3/14_concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day2/10_error_handling.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day3/14_concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
