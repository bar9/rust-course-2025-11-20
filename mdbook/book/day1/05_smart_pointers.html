<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ownership Patterns &amp; Smart Pointers - Rust Course 2025</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Interactive Rust programming course built with mdBook">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Course 2025</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18/edit/main/mdbook/src/day1/05_smart_pointers.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-5-smart-pointers"><a class="header" href="#chapter-5-smart-pointers">Chapter 5: Smart Pointers</a></h1>
<h2 id="advanced-memory-management-beyond-basic-ownership"><a class="header" href="#advanced-memory-management-beyond-basic-ownership">Advanced Memory Management Beyond Basic Ownership</a></h2>
<h3 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h3>
<p>By the end of this chapter, you’ll be able to:</p>
<ul>
<li>Use Box<T> for heap allocation and recursive data structures</li>
<li>Share ownership safely with Rc<T> and Arc<T></li>
<li>Implement interior mutability with RefCell<T> and Mutex<T></li>
<li>Prevent memory leaks with Weak<T> references</li>
<li>Choose the right smart pointer for different scenarios</li>
<li>Understand the performance implications of each smart pointer type</li>
</ul>
<hr />
<h2 id="what-are-smart-pointers"><a class="header" href="#what-are-smart-pointers">What Are Smart Pointers?</a></h2>
<p>Smart pointers are data structures that act like pointers but have additional metadata and capabilities. Unlike regular references, smart pointers <strong>own</strong> the data they point to.</p>
<h3 id="smart-pointers-vs-regular-references"><a class="header" href="#smart-pointers-vs-regular-references">Smart Pointers vs Regular References</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Regular Reference</th><th>Smart Pointer</th></tr></thead><tbody>
<tr><td>Ownership</td><td>Borrows data</td><td>Owns data</td></tr>
<tr><td>Memory location</td><td>Stack or heap</td><td>Usually heap</td></tr>
<tr><td>Deallocation</td><td>Automatic (owner drops)</td><td>Automatic (smart pointer drops)</td></tr>
<tr><td>Runtime overhead</td><td>None</td><td>Some (depends on type)</td></tr>
</tbody></table>
</div>
<h3 id="comparison-with-cnet"><a class="header" href="#comparison-with-cnet">Comparison with C++/.NET</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>C++ Equivalent</th><th>C#/.NET Equivalent</th></tr></thead><tbody>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>std::unique_ptr&lt;T&gt;</code></td><td>No direct equivalent</td></tr>
<tr><td><code>Rc&lt;T&gt;</code></td><td><code>std::shared_ptr&lt;T&gt;</code></td><td>Reference counting GC</td></tr>
<tr><td><code>Arc&lt;T&gt;</code></td><td><code>std::shared_ptr&lt;T&gt;</code> (thread-safe)</td><td>Thread-safe references</td></tr>
<tr><td><code>RefCell&lt;T&gt;</code></td><td>No equivalent</td><td>Lock-free interior mutability</td></tr>
<tr><td><code>Weak&lt;T&gt;</code></td><td><code>std::weak_ptr&lt;T&gt;</code></td><td><code>WeakReference&lt;T&gt;</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="box-single-ownership-on-the-heap"><a class="header" href="#box-single-ownership-on-the-heap">Box<T>: Single Ownership on the Heap</a></h2>
<p><code>Box&lt;T&gt;</code> is the simplest smart pointer - it provides heap allocation with single ownership.</p>
<h3 id="when-to-use-box"><a class="header" href="#when-to-use-box">When to Use Box<T></a></h3>
<ol>
<li><strong>Large data</strong>: Move large structs to heap to avoid stack overflow</li>
<li><strong>Recursive types</strong>: Enable recursive data structures</li>
<li><strong>Trait objects</strong>: Store different types behind a common trait</li>
<li><strong>Unsized types</strong>: Store dynamically sized types</li>
</ol>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Heap allocation
    let b = Box::new(5);
    println!("b = {}", b);  // Box implements Deref, so this works
    
    // Large struct - better on heap
    struct LargeStruct {
        data: [u8; 1024 * 1024],  // 1MB
    }
    
    let large = Box::new(LargeStruct { data: [0; 1024 * 1024] });
    // Only pointer stored on stack, data on heap
}</code></pre></pre>
<h3 id="recursive-data-structures"><a class="header" href="#recursive-data-structures">Recursive Data Structures</a></h3>
<pre><pre class="playground"><code class="language-rust">// ❌ This won't compile - infinite size
// enum List {
//     Cons(i32, List),
//     Nil,
// }

// ✅ This works - Box has known size
#[derive(Debug)]
enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

impl List {
    fn new() -&gt; List {
        List::Nil
    }
    
    fn prepend(self, elem: i32) -&gt; List {
        List::Cons(elem, Box::new(self))
    }
    
    fn len(&amp;self) -&gt; usize {
        match self {
            List::Cons(_, tail) =&gt; 1 + tail.len(),
            List::Nil =&gt; 0,
        }
    }
}

fn main() {
    let list = List::new()
        .prepend(1)
        .prepend(2)
        .prepend(3);
    
    println!("List: {:?}", list);
    println!("Length: {}", list.len());
}</code></pre></pre>
<h3 id="box-with-trait-objects"><a class="header" href="#box-with-trait-objects">Box with Trait Objects</a></h3>
<pre><pre class="playground"><code class="language-rust">trait Draw {
    fn draw(&amp;self);
}

struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Draw for Circle {
    fn draw(&amp;self) {
        println!("Drawing circle with radius {}", self.radius);
    }
}

impl Draw for Rectangle {
    fn draw(&amp;self) {
        println!("Drawing rectangle {}x{}", self.width, self.height);
    }
}

fn main() {
    let shapes: Vec&lt;Box&lt;dyn Draw&gt;&gt; = vec![
        Box::new(Circle { radius: 5.0 }),
        Box::new(Rectangle { width: 10.0, height: 5.0 }),
    ];
    
    for shape in shapes {
        shape.draw();
    }
}</code></pre></pre>
<hr />
<h2 id="rc-reference-counted-single-threaded-sharing"><a class="header" href="#rc-reference-counted-single-threaded-sharing">Rc<T>: Reference Counted Single-Threaded Sharing</a></h2>
<p><code>Rc&lt;T&gt;</code> (Reference Counted) enables multiple ownership of the same data in single-threaded scenarios.</p>
<h3 id="when-to-use-rc"><a class="header" href="#when-to-use-rc">When to Use Rc<T></a></h3>
<ul>
<li>Multiple owners need to read the same data</li>
<li>Data lifetime is determined by multiple owners</li>
<li>Single-threaded environment only</li>
<li>Shared immutable data structures (graphs, trees)</li>
</ul>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {
    let a = Rc::new(5);
    println!("Reference count: {}", Rc::strong_count(&amp;a));  // 1
    
    let b = Rc::clone(&amp;a);  // Shallow clone, increases ref count
    println!("Reference count: {}", Rc::strong_count(&amp;a));  // 2
    
    {
        let c = Rc::clone(&amp;a);
        println!("Reference count: {}", Rc::strong_count(&amp;a));  // 3
    }  // c dropped here
    
    println!("Reference count: {}", Rc::strong_count(&amp;a));  // 2
}  // a and b dropped here, memory freed when count reaches 0</code></pre></pre>
<h3 id="sharing-lists"><a class="header" href="#sharing-lists">Sharing Lists</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

fn main() {
    let a = Rc::new(List::Cons(5, 
        Rc::new(List::Cons(10, 
        Rc::new(List::Nil)))));
    
    let b = List::Cons(3, Rc::clone(&amp;a));
    let c = List::Cons(4, Rc::clone(&amp;a));
    
    println!("List a: {:?}", a);
    println!("List b: {:?}", b);
    println!("List c: {:?}", c);
    println!("Reference count for a: {}", Rc::strong_count(&amp;a));  // 3
}</code></pre></pre>
<h3 id="tree-with-shared-subtrees"><a class="header" href="#tree-with-shared-subtrees">Tree with Shared Subtrees</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

#[derive(Debug)]
struct TreeNode {
    value: i32,
    left: Option&lt;Rc&lt;TreeNode&gt;&gt;,
    right: Option&lt;Rc&lt;TreeNode&gt;&gt;,
}

impl TreeNode {
    fn new(value: i32) -&gt; Rc&lt;Self&gt; {
        Rc::new(TreeNode {
            value,
            left: None,
            right: None,
        })
    }
    
    fn with_children(value: i32, left: Option&lt;Rc&lt;TreeNode&gt;&gt;, right: Option&lt;Rc&lt;TreeNode&gt;&gt;) -&gt; Rc&lt;Self&gt; {
        Rc::new(TreeNode { value, left, right })
    }
}

fn main() {
    // Shared subtree
    let shared_subtree = TreeNode::with_children(
        10,
        Some(TreeNode::new(5)),
        Some(TreeNode::new(15)),
    );
    
    // Two different trees sharing the same subtree
    let tree1 = TreeNode::with_children(1, Some(Rc::clone(&amp;shared_subtree)), None);
    let tree2 = TreeNode::with_children(2, Some(Rc::clone(&amp;shared_subtree)), None);
    
    println!("Tree 1: {:?}", tree1);
    println!("Tree 2: {:?}", tree2);
    println!("Shared subtree references: {}", Rc::strong_count(&amp;shared_subtree));  // 3
}</code></pre></pre>
<hr />
<h2 id="refcell-interior-mutability"><a class="header" href="#refcell-interior-mutability">RefCell<T>: Interior Mutability</a></h2>
<p><code>RefCell&lt;T&gt;</code> provides “interior mutability” - the ability to mutate data even when there are immutable references to it. The borrowing rules are enforced at runtime instead of compile time.</p>
<h3 id="when-to-use-refcell"><a class="header" href="#when-to-use-refcell">When to Use RefCell<T></a></h3>
<ul>
<li>You need to mutate data behind shared references</li>
<li>You’re certain the borrowing rules are followed, but the compiler can’t verify it</li>
<li>Implementing patterns that require mutation through shared references</li>
<li>Building mock objects for testing</li>
</ul>
<h3 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);
    
    // Borrow immutably
    {
        let r1 = data.borrow();
        let r2 = data.borrow();
        println!("r1: {}, r2: {}", r1, r2);  // Multiple immutable borrows OK
    }  // Borrows dropped here
    
    // Borrow mutably
    {
        let mut r3 = data.borrow_mut();
        *r3 = 10;
    }  // Mutable borrow dropped here
    
    println!("Final value: {}", data.borrow());
}</code></pre></pre>
<h3 id="runtime-borrow-checking"><a class="header" href="#runtime-borrow-checking">Runtime Borrow Checking</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);
    
    let r1 = data.borrow();
    // let r2 = data.borrow_mut();  // ❌ Panic! Already borrowed immutably
    
    drop(r1);  // Drop immutable borrow
    let r2 = data.borrow_mut();  // ✅ OK now
    println!("Mutably borrowed: {}", r2);
}</code></pre></pre>
<h3 id="combining-rc-and-refcell"><a class="header" href="#combining-rc-and-refcell">Combining Rc<T> and RefCell<T></a></h3>
<p>This is a common pattern for shared mutable data:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: Vec&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    fn new(value: i32) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            value,
            children: Vec::new(),
        }))
    }
    
    fn add_child(parent: &amp;Rc&lt;RefCell&lt;Node&gt;&gt;, child: Rc&lt;RefCell&lt;Node&gt;&gt;) {
        parent.borrow_mut().children.push(child);
    }
}

fn main() {
    let root = Node::new(1);
    let child1 = Node::new(2);
    let child2 = Node::new(3);
    
    Node::add_child(&amp;root, child1);
    Node::add_child(&amp;root, child2);
    
    println!("Root: {:?}", root);
    
    // Modify child through shared reference
    root.borrow().children[0].borrow_mut().value = 20;
    
    println!("Modified root: {:?}", root);
}</code></pre></pre>
<hr />
<h2 id="arc-atomic-reference-counting-for-concurrency"><a class="header" href="#arc-atomic-reference-counting-for-concurrency">Arc<T>: Atomic Reference Counting for Concurrency</a></h2>
<p><code>Arc&lt;T&gt;</code> (Atomically Reference Counted) is the thread-safe version of <code>Rc&lt;T&gt;</code>.</p>
<h3 id="when-to-use-arc"><a class="header" href="#when-to-use-arc">When to Use Arc<T></a></h3>
<ul>
<li>Multiple threads need to share ownership of data</li>
<li>Thread-safe reference counting is needed</li>
<li>Sharing immutable data across thread boundaries</li>
</ul>
<h3 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&amp;data);
        let handle = thread::spawn(move || {
            println!("Thread {}: {:?}", i, data_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Reference count: {}", Arc::strong_count(&amp;data));  // Back to 1
}</code></pre></pre>
<h3 id="arcmutex-shared-mutable-state"><a class="header" href="#arcmutex-shared-mutable-state">Arc&lt;Mutex<T>&gt;: Shared Mutable State</a></h3>
<p>For mutable shared data across threads, combine <code>Arc&lt;T&gt;</code> with <code>Mutex&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter_clone.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final count: {}", *counter.lock().unwrap());  // Should be 10
}</code></pre></pre>
<hr />
<h2 id="weak-breaking-reference-cycles"><a class="header" href="#weak-breaking-reference-cycles">Weak<T>: Breaking Reference Cycles</a></h2>
<p><code>Weak&lt;T&gt;</code> provides a non-owning reference that doesn’t affect reference counting. It’s used to break reference cycles that would cause memory leaks.</p>
<h3 id="the-reference-cycle-problem"><a class="header" href="#the-reference-cycle-problem">The Reference Cycle Problem</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,      // Weak reference to parent
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;, // Strong references to children
}

impl Node {
    fn new(value: i32) -&gt; Rc&lt;Self&gt; {
        Rc::new(Node {
            value,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(Vec::new()),
        })
    }
    
    fn add_child(parent: &amp;Rc&lt;Node&gt;, child: Rc&lt;Node&gt;) {
        // Set parent weak reference
        *child.parent.borrow_mut() = Rc::downgrade(parent);
        // Add child strong reference
        parent.children.borrow_mut().push(child);
    }
}

fn main() {
    let parent = Node::new(1);
    let child = Node::new(2);
    
    Node::add_child(&amp;parent, child);
    
    // Access parent from child
    let parent_from_child = parent.children.borrow()[0]
        .parent
        .borrow()
        .upgrade();  // Convert weak to strong reference
    
    if let Some(parent_ref) = parent_from_child {
        println!("Child's parent value: {}", parent_ref.value);
    }
    
    println!("Parent strong count: {}", Rc::strong_count(&amp;parent));  // 1
    println!("Parent weak count: {}", Rc::weak_count(&amp;parent));      // 1
}</code></pre></pre>
<h3 id="observer-pattern-with-weak-references"><a class="header" href="#observer-pattern-with-weak-references">Observer Pattern with Weak References</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::rc::{Rc, Weak};
use std::cell::RefCell;

trait Observer {
    fn notify(&amp;self, message: &amp;str);
}

struct Subject {
    observers: RefCell&lt;Vec&lt;Weak&lt;dyn Observer&gt;&gt;&gt;,
}

impl Subject {
    fn new() -&gt; Self {
        Subject {
            observers: RefCell::new(Vec::new()),
        }
    }
    
    fn subscribe(&amp;self, observer: Weak&lt;dyn Observer&gt;) {
        self.observers.borrow_mut().push(observer);
    }
    
    fn notify_all(&amp;self, message: &amp;str) {
        let mut observers = self.observers.borrow_mut();
        observers.retain(|weak_observer| {
            if let Some(observer) = weak_observer.upgrade() {
                observer.notify(message);
                true  // Keep this observer
            } else {
                false  // Remove dead observer
            }
        });
    }
}

struct ConcreteObserver {
    id: String,
}

impl Observer for ConcreteObserver {
    fn notify(&amp;self, message: &amp;str) {
        println!("Observer {} received: {}", self.id, message);
    }
}

fn main() {
    let subject = Subject::new();
    
    {
        let observer1 = Rc::new(ConcreteObserver { id: "1".to_string() });
        let observer2 = Rc::new(ConcreteObserver { id: "2".to_string() });
        
        subject.subscribe(Rc::downgrade(&amp;observer1));
        subject.subscribe(Rc::downgrade(&amp;observer2));
        
        subject.notify_all("Hello observers!");
    }  // Observers dropped here
    
    subject.notify_all("Anyone still listening?");  // Dead observers cleaned up
}</code></pre></pre>
<hr />
<h2 id="choosing-the-right-smart-pointer"><a class="header" href="#choosing-the-right-smart-pointer">Choosing the Right Smart Pointer</a></h2>
<h3 id="decision-tree"><a class="header" href="#decision-tree">Decision Tree</a></h3>
<pre><code>Do you need shared ownership?
├─ No → Use Box&lt;T&gt;
└─ Yes
   ├─ Single threaded?
   │  ├─ Yes
   │  │  ├─ Need interior mutability? → Rc&lt;RefCell&lt;T&gt;&gt;
   │  │  └─ Just sharing? → Rc&lt;T&gt;
   │  └─ No (multi-threaded)
   │     ├─ Need interior mutability? → Arc&lt;Mutex&lt;T&gt;&gt;
   │     └─ Just sharing? → Arc&lt;T&gt;
   └─ Breaking cycles? → Use Weak&lt;T&gt; in combination
</code></pre>
<h3 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Smart Pointer</th><th>Allocation</th><th>Reference Counting</th><th>Thread Safety</th><th>Interior Mutability</th></tr></thead><tbody>
<tr><td><code>Box&lt;T&gt;</code></td><td>Heap</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td><code>Rc&lt;T&gt;</code></td><td>Heap</td><td>Yes (non-atomic)</td><td>No</td><td>No</td></tr>
<tr><td><code>Arc&lt;T&gt;</code></td><td>Heap</td><td>Yes (atomic)</td><td>Yes</td><td>No</td></tr>
<tr><td><code>RefCell&lt;T&gt;</code></td><td>Stack/Heap</td><td>No</td><td>No</td><td>Yes (runtime)</td></tr>
<tr><td><code>Weak&lt;T&gt;</code></td><td>No allocation</td><td>Weak counting</td><td>Depends on target</td><td>No</td></tr>
</tbody></table>
</div>
<h3 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::{Rc, Weak};
use std::cell::RefCell;
use std::sync::{Arc, Mutex};

// Pattern 1: Immutable shared data (single-threaded)
fn pattern1() {
    let shared_data = Rc::new(vec![1, 2, 3, 4, 5]);
    let clone1 = Rc::clone(&amp;shared_data);
    let clone2 = Rc::clone(&amp;shared_data);
    // Multiple readers, no writers
}

// Pattern 2: Mutable shared data (single-threaded)
fn pattern2() {
    let shared_data = Rc::new(RefCell::new(vec![1, 2, 3]));
    shared_data.borrow_mut().push(4);
    let len = shared_data.borrow().len();
}

// Pattern 3: Immutable shared data (multi-threaded)
fn pattern3() {
    let shared_data = Arc::new(vec![1, 2, 3, 4, 5]);
    let clone = Arc::clone(&amp;shared_data);
    std::thread::spawn(move || {
        println!("{:?}", clone);
    });
}

// Pattern 4: Mutable shared data (multi-threaded)
fn pattern4() {
    let shared_data = Arc::new(Mutex::new(vec![1, 2, 3]));
    let clone = Arc::clone(&amp;shared_data);
    std::thread::spawn(move || {
        clone.lock().unwrap().push(4);
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="common-pitfalls-and-solutions"><a class="header" href="#common-pitfalls-and-solutions">Common Pitfalls and Solutions</a></h2>
<h3 id="pitfall-1-reference-cycles-with-rc"><a class="header" href="#pitfall-1-reference-cycles-with-rc">Pitfall 1: Reference Cycles with Rc<T></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;

// ❌ This creates a reference cycle and memory leak
#[derive(Debug)]
struct BadNode {
    children: RefCell&lt;Vec&lt;Rc&lt;BadNode&gt;&gt;&gt;,
    parent: RefCell&lt;Option&lt;Rc&lt;BadNode&gt;&gt;&gt;,  // Strong reference = cycle!
}

// ✅ Use Weak for parent references
#[derive(Debug)]
struct GoodNode {
    children: RefCell&lt;Vec&lt;Rc&lt;GoodNode&gt;&gt;&gt;,
    parent: RefCell&lt;Option&lt;std::rc::Weak&lt;GoodNode&gt;&gt;&gt;,  // Weak reference
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pitfall-2-refcell-runtime-panics"><a class="header" href="#pitfall-2-refcell-runtime-panics">Pitfall 2: RefCell Runtime Panics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

fn dangerous_refcell() {
    let data = RefCell::new(5);
    
    let _r1 = data.borrow();
    let _r2 = data.borrow_mut();  // ❌ Panics at runtime!
}

// ✅ Safe RefCell usage
fn safe_refcell() {
    let data = RefCell::new(5);
    
    {
        let r1 = data.borrow();
        println!("Value: {}", r1);
    }  // r1 dropped
    
    {
        let mut r2 = data.borrow_mut();
        *r2 = 10;
    }  // r2 dropped
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pitfall-3-unnecessary-arc-for-single-threaded-code"><a class="header" href="#pitfall-3-unnecessary-arc-for-single-threaded-code">Pitfall 3: Unnecessary Arc for Single-Threaded Code</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Unnecessary atomic operations
use std::sync::Arc;
fn single_threaded_sharing() {
    let data = Arc::new(vec![1, 2, 3]);  // Atomic ref counting overhead
    // ... single-threaded code only
}

// ✅ Use Rc for single-threaded sharing
use std::rc::Rc;
fn single_threaded_sharing_optimized() {
    let data = Rc::new(vec![1, 2, 3]);  // Faster non-atomic ref counting
    // ... single-threaded code only
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li><strong>Box<T></strong> for single ownership heap allocation and recursive types</li>
<li><strong>Rc<T></strong> for shared ownership in single-threaded contexts</li>
<li><strong>RefCell<T></strong> for interior mutability with runtime borrow checking</li>
<li><strong>Arc<T></strong> for shared ownership across threads</li>
<li><strong>Weak<T></strong> to break reference cycles and avoid memory leaks</li>
<li><strong>Combine smart pointers</strong> for complex sharing patterns (e.g., <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>)</li>
<li><strong>Choose based on threading and mutability needs</strong></li>
</ol>
<hr />
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="exercise-1-binary-tree-with-parent-references"><a class="header" href="#exercise-1-binary-tree-with-parent-references">Exercise 1: Binary Tree with Parent References</a></h3>
<p>Implement a binary tree where nodes can access both children and parents without creating reference cycles:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct TreeNode {
    value: i32,
    left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
    right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
    parent: RefCell&lt;Weak&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
}

impl TreeNode {
    fn new(value: i32) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        // Implement
    }
    
    fn add_left_child(node: &amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;, value: i32) {
        // Implement: Add left child and set its parent reference
    }
    
    fn add_right_child(node: &amp;Rc&lt;RefCell&lt;TreeNode&gt;&gt;, value: i32) {
        // Implement: Add right child and set its parent reference
    }
    
    fn get_parent_value(&amp;self) -&gt; Option&lt;i32&gt; {
        // Implement: Get parent's value if it exists
    }
    
    fn find_root(&amp;self) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
        // Implement: Traverse up to find root node
    }
}

fn main() {
    let root = TreeNode::new(1);
    TreeNode::add_left_child(&amp;root, 2);
    TreeNode::add_right_child(&amp;root, 3);
    
    let left_child = root.borrow().left.as_ref().unwrap().clone();
    TreeNode::add_left_child(&amp;left_child, 4);
    
    // Test parent access
    let grandchild = left_child.borrow().left.as_ref().unwrap().clone();
    println!("Grandchild's parent: {:?}", grandchild.borrow().get_parent_value());
    
    // Test root finding
    if let Some(found_root) = grandchild.borrow().find_root() {
        println!("Root value: {}", found_root.borrow().value);
    }
}</code></pre></pre>
<h3 id="exercise-2-thread-safe-cache"><a class="header" href="#exercise-2-thread-safe-cache">Exercise 2: Thread-Safe Cache</a></h3>
<p>Implement a thread-safe cache using Arc and Mutex:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;

struct Cache&lt;K, V&gt; {
    data: Arc&lt;Mutex&lt;HashMap&lt;K, V&gt;&gt;&gt;,
}

impl&lt;K, V&gt; Cache&lt;K, V&gt; 
where
    K: Clone + Eq + std::hash::Hash + Send + 'static,
    V: Clone + Send + 'static,
{
    fn new() -&gt; Self {
        // Implement
    }
    
    fn get(&amp;self, key: &amp;K) -&gt; Option&lt;V&gt; {
        // Implement: Get value from cache
    }
    
    fn set(&amp;self, key: K, value: V) {
        // Implement: Set value in cache
    }
    
    fn size(&amp;self) -&gt; usize {
        // Implement: Get cache size
    }
}

impl&lt;K, V&gt; Clone for Cache&lt;K, V&gt; {
    fn clone(&amp;self) -&gt; Self {
        // Implement: Clone should share the same underlying data
        Cache {
            data: Arc::clone(&amp;self.data),
        }
    }
}

fn main() {
    let cache = Cache::new();
    let mut handles = vec![];
    
    // Spawn multiple threads that use the cache
    for i in 0..5 {
        let cache_clone = cache.clone();
        let handle = thread::spawn(move || {
            // Set some values
            cache_clone.set(format!("key{}", i), i * 10);
            
            // Get some values
            if let Some(value) = cache_clone.get(&amp;format!("key{}", i)) {
                println!("Thread {}: got value {}", i, value);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("Final cache size: {}", cache.size());
}</code></pre></pre>
<h3 id="exercise-3-observer-pattern-with-automatic-cleanup"><a class="header" href="#exercise-3-observer-pattern-with-automatic-cleanup">Exercise 3: Observer Pattern with Automatic Cleanup</a></h3>
<p>Extend the observer pattern to automatically clean up observers and provide subscription management:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::{Rc, Weak};
use std::cell::RefCell;

trait Observer {
    fn update(&amp;self, data: &amp;str);
    fn id(&amp;self) -&gt; &amp;str;
}

struct Subject {
    observers: RefCell&lt;Vec&lt;Weak&lt;dyn Observer&gt;&gt;&gt;,
}

impl Subject {
    fn new() -&gt; Self {
        // Implement
    }
    
    fn subscribe(&amp;self, observer: Weak&lt;dyn Observer&gt;) {
        // Implement: Add observer
    }
    
    fn unsubscribe(&amp;self, observer_id: &amp;str) {
        // Implement: Remove observer by ID
    }
    
    fn notify(&amp;self, data: &amp;str) {
        // Implement: Notify all observers, cleaning up dead ones
    }
    
    fn observer_count(&amp;self) -&gt; usize {
        // Implement: Count living observers
    }
}

struct ConcreteObserver {
    id: String,
}

impl ConcreteObserver {
    fn new(id: String) -&gt; Rc&lt;Self&gt; {
        Rc::new(ConcreteObserver { id })
    }
}

impl Observer for ConcreteObserver {
    fn update(&amp;self, data: &amp;str) {
        println!("Observer {} received: {}", self.id, data);
    }
    
    fn id(&amp;self) -&gt; &amp;str {
        &amp;self.id
    }
}

fn main() {
    let subject = Subject::new();
    
    let observer1 = ConcreteObserver::new("obs1".to_string());
    let observer2 = ConcreteObserver::new("obs2".to_string());
    
    subject.subscribe(Rc::downgrade(&amp;observer1));
    subject.subscribe(Rc::downgrade(&amp;observer2));
    
    subject.notify("First message");
    println!("Observer count: {}", subject.observer_count());
    
    // Drop one observer
    drop(observer1);
    
    subject.notify("Second message");
    println!("Observer count after cleanup: {}", subject.observer_count());
    
    subject.unsubscribe("obs2");
    subject.notify("Third message");
    println!("Final observer count: {}", subject.observer_count());
}</code></pre></pre>
<p><strong>Next Up:</strong> In Day 2, we’ll explore collections, traits, and generics - the tools that make Rust code both safe and expressive.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day1/04_ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day2/06_collections.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day1/04_ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day2/06_collections.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
