<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Memory Model &amp; Ownership - Rust Course 2025</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Interactive Rust programming course built with mdBook">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Course 2025</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18/edit/main/mdbook/src/day1/04_ownership.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-4-ownership---the-most-important-concept"><a class="header" href="#chapter-4-ownership---the-most-important-concept">Chapter 4: Ownership - THE MOST IMPORTANT CONCEPT</a></h1>
<h2 id="understanding-rusts-unique-memory-management"><a class="header" href="#understanding-rusts-unique-memory-management">Understanding Rust’s Unique Memory Management</a></h2>
<h3 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h3>
<p>By the end of this chapter, you’ll be able to:</p>
<ul>
<li>Understand ownership rules and how they differ from C++/.NET memory management</li>
<li>Work confidently with borrowing and references</li>
<li>Navigate lifetime annotations and understand when they’re needed</li>
<li>Transfer ownership safely between functions and data structures</li>
<li>Debug common ownership errors with confidence</li>
<li>Apply ownership principles to write memory-safe, performant code</li>
</ul>
<hr />
<h2 id="why-ownership-matters-the-problem-it-solves"><a class="header" href="#why-ownership-matters-the-problem-it-solves">Why Ownership Matters: The Problem It Solves</a></h2>
<h3 id="memory-management-comparison"><a class="header" href="#memory-management-comparison">Memory Management Comparison</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Language</th><th>Memory Management</th><th>Common Issues</th><th>Performance</th><th>Safety</th></tr></thead><tbody>
<tr><td><strong>C++</strong></td><td>Manual (new/delete, RAII)</td><td>Memory leaks, double-free, dangling pointers</td><td>High</td><td>Runtime crashes</td></tr>
<tr><td><strong>C#/.NET</strong></td><td>Garbage Collector</td><td>GC pauses, memory pressure</td><td>Medium</td><td>Runtime exceptions</td></tr>
<tr><td><strong>Rust</strong></td><td>Compile-time ownership</td><td>Compiler errors (not runtime!)</td><td>High</td><td>Compile-time safety</td></tr>
</tbody></table>
</div>
<h3 id="the-core-problem"><a class="header" href="#the-core-problem">The Core Problem</a></h3>
<pre><code class="language-cpp">// C++ - Dangerous code that compiles
std::string* dangerous() {
    std::string local = "Hello";
    return &amp;local;  // ❌ Returning reference to local variable!
}
// This compiles but crashes at runtime

// C# - Memory managed but can still have issues
class Manager {
    private List&lt;string&gt; items;
    
    public IEnumerable&lt;string&gt; GetItems() {
        items = null;  // Oops!
        return items;  // ❌ NullReferenceException at runtime
    }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust - Won't compile, saving you from runtime crashes
fn safe_rust() -&gt; &amp;str {
    let local = String::from("Hello");
    &amp;local  // ❌ Compile error: `local` does not live long enough
}
// Error caught at compile time!
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="the-three-rules-of-ownership"><a class="header" href="#the-three-rules-of-ownership">The Three Rules of Ownership</a></h2>
<h3 id="rule-1-each-value-has-a-single-owner"><a class="header" href="#rule-1-each-value-has-a-single-owner">Rule 1: Each Value Has a Single Owner</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from("Hello");    // s1 owns the string
let s2 = s1;                       // Ownership moves to s2
// println!("{}", s1);             // ❌ Error: value borrowed after move

// Compare to C++:
// std::string s1 = "Hello";       // s1 owns the string  
// std::string s2 = s1;            // s2 gets a COPY (expensive!)
// std::cout &lt;&lt; s1;                // ✅ Still works, s1 unchanged
<span class="boring">}</span></code></pre></pre>
<h3 id="rule-2-there-can-only-be-one-owner-at-a-time"><a class="header" href="#rule-2-there-can-only-be-one-owner-at-a-time">Rule 2: There Can Only Be One Owner at a Time</a></h3>
<pre><pre class="playground"><code class="language-rust">fn take_ownership(s: String) {     // s comes into scope
    println!("{}", s);
}   // s goes out of scope and `drop` is called, memory freed

fn main() {
    let s = String::from("Hello");
    take_ownership(s);             // s's value moves into function
    // println!("{}", s);          // ❌ Error: value borrowed after move
}</code></pre></pre>
<h3 id="rule-3-when-the-owner-goes-out-of-scope-the-value-is-dropped"><a class="header" href="#rule-3-when-the-owner-goes-out-of-scope-the-value-is-dropped">Rule 3: When the Owner Goes Out of Scope, the Value is Dropped</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from("Hello");  // s comes into scope
    // do stuff with s
}                                   // s goes out of scope, memory freed automatically
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="move-semantics-ownership-transfer"><a class="header" href="#move-semantics-ownership-transfer">Move Semantics: Ownership Transfer</a></h2>
<h3 id="understanding-moves"><a class="header" href="#understanding-moves">Understanding Moves</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Primitive types implement Copy trait
let x = 5;
let y = x;              // x is copied, both x and y are valid
println!("x: {}, y: {}", x, y);  // ✅ Works fine

// Complex types move by default
let s1 = String::from("Hello");
let s2 = s1;            // s1 is moved to s2
// println!("{}", s1);  // ❌ Error: value borrowed after move
println!("{}", s2);     // ✅ Only s2 is valid

// Clone when you need a copy
let s3 = String::from("World");
let s4 = s3.clone();    // Explicit copy
println!("s3: {}, s4: {}", s3, s4);  // ✅ Both valid
<span class="boring">}</span></code></pre></pre>
<h3 id="copy-vs-move-types"><a class="header" href="#copy-vs-move-types">Copy vs Move Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Types that implement Copy (stored on stack)
let a = 5;        // i32
let b = true;     // bool
let c = 'a';      // char
let d = (1, 2);   // Tuple of Copy types

// Types that don't implement Copy (may use heap)
let e = String::from("Hello");     // String
let f = vec![1, 2, 3];            // Vec&lt;i32&gt;
let g = Box::new(42);             // Box&lt;i32&gt;

// Copy types can be used after assignment
let x = a;  // a is copied
println!("a: {}, x: {}", a, x);   // ✅ Both work

// Move types transfer ownership
let y = e;  // e is moved
// println!("{}", e);             // ❌ Error: moved
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="references-and-borrowing"><a class="header" href="#references-and-borrowing">References and Borrowing</a></h2>
<h3 id="immutable-references-shared-borrowing"><a class="header" href="#immutable-references-shared-borrowing">Immutable References (Shared Borrowing)</a></h3>
<pre><pre class="playground"><code class="language-rust">fn calculate_length(s: &amp;String) -&gt; usize {  // s is a reference
    s.len()
}   // s goes out of scope, but doesn't own data, so nothing happens

fn main() {
    let s1 = String::from("Hello");
    let len = calculate_length(&amp;s1);        // Pass reference
    println!("Length of '{}' is {}.", s1, len);  // ✅ s1 still usable
}</code></pre></pre>
<h3 id="mutable-references-exclusive-borrowing"><a class="header" href="#mutable-references-exclusive-borrowing">Mutable References (Exclusive Borrowing)</a></h3>
<pre><pre class="playground"><code class="language-rust">fn change(s: &amp;mut String) {
    s.push_str(", world");
}

fn main() {
    let mut s = String::from("Hello");
    change(&amp;mut s);                         // Pass mutable reference
    println!("{}", s);                      // Prints: Hello, world
}</code></pre></pre>
<h3 id="the-borrowing-rules"><a class="header" href="#the-borrowing-rules">The Borrowing Rules</a></h3>
<p><strong>Rule 1: Either one mutable reference OR any number of immutable references</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from("Hello");

// ✅ Multiple immutable references
let r1 = &amp;s;
let r2 = &amp;s;
println!("{} and {}", r1, r2);  // OK

// ❌ Cannot have mutable reference with immutable ones
let r3 = &amp;s;
let r4 = &amp;mut s;  // Error: cannot borrow as mutable
<span class="boring">}</span></code></pre></pre>
<p><strong>Rule 2: References must always be valid (no dangling references)</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dangle() -&gt; &amp;String {        // Returns reference to String
    let s = String::from("hello");
    &amp;s                          // ❌ Error: `s` does not live long enough
}   // s is dropped, reference would be invalid

// ✅ Solution: Return owned value
fn no_dangle() -&gt; String {
    let s = String::from("hello");
    s                           // Move s out, no reference needed
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reference-patterns-in-practice"><a class="header" href="#reference-patterns-in-practice">Reference Patterns in Practice</a></h3>
<pre><pre class="playground"><code class="language-rust">// Good: Take references when you don't need ownership
fn print_length(s: &amp;str) {      // &amp;str works with String and &amp;str
    println!("Length: {}", s.len());
}

// Good: Take mutable reference when you need to modify
fn append_exclamation(s: &amp;mut String) {
    s.push('!');
}

// Sometimes you need ownership
fn take_and_process(s: String) -&gt; String {
    // Do expensive processing that consumes s
    format!("Processed: {}", s.to_uppercase())
}

fn main() {
    let mut text = String::from("Hello");
    
    print_length(&amp;text);        // Borrow immutably
    append_exclamation(&amp;mut text);  // Borrow mutably  
    
    let result = take_and_process(text);  // Transfer ownership
    // text is no longer valid here
    println!("{}", result);
}</code></pre></pre>
<hr />
<h2 id="lifetimes-ensuring-reference-validity"><a class="header" href="#lifetimes-ensuring-reference-validity">Lifetimes: Ensuring Reference Validity</a></h2>
<h3 id="why-lifetimes-exist"><a class="header" href="#why-lifetimes-exist">Why Lifetimes Exist</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The compiler needs to ensure this is safe:
fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
// Question: How long should the returned reference live?
<span class="boring">}</span></code></pre></pre>
<h3 id="lifetime-annotation-syntax"><a class="header" href="#lifetime-annotation-syntax">Lifetime Annotation Syntax</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Explicit lifetime annotations
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

// The lifetime 'a means:
// - x and y must both live at least as long as 'a
// - The returned reference will live as long as 'a
// - 'a is the shorter of the two input lifetimes
<span class="boring">}</span></code></pre></pre>
<h3 id="lifetime-elision-rules-when-you-dont-need-annotations"><a class="header" href="#lifetime-elision-rules-when-you-dont-need-annotations">Lifetime Elision Rules (When You Don’t Need Annotations)</a></h3>
<p><strong>Rule 1:</strong> Each reference parameter gets its own lifetime</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This:
fn first_word(s: &amp;str) -&gt; &amp;str { /* ... */ }
// Is actually this:
fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p><strong>Rule 2:</strong> If there’s exactly one input lifetime, it’s assigned to all outputs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These are equivalent:
fn get_first(list: &amp;Vec&lt;String&gt;) -&gt; &amp;String { &amp;list[0] }
fn get_first&lt;'a&gt;(list: &amp;'a Vec&lt;String&gt;) -&gt; &amp;'a String { &amp;list[0] }
<span class="boring">}</span></code></pre></pre>
<p><strong>Rule 3:</strong> Methods with <code>&amp;self</code> give output the same lifetime as <code>self</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Person&lt;'a&gt; {
    fn get_name(&amp;self) -&gt; &amp;str {  // Implicitly &amp;'a str
        self.name
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="complex-lifetime-examples"><a class="header" href="#complex-lifetime-examples">Complex Lifetime Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Multiple lifetimes
fn compare_and_return&lt;'a, 'b&gt;(
    x: &amp;'a str, 
    y: &amp;'b str, 
    return_first: bool
) -&gt; &amp;'a str {  // Always returns something with lifetime 'a
    if return_first { x } else { y }  // ❌ Error: y has wrong lifetime
}

// Fixed version - both inputs must have same lifetime
fn compare_and_return&lt;'a&gt;(
    x: &amp;'a str, 
    y: &amp;'a str, 
    return_first: bool
) -&gt; &amp;'a str {
    if return_first { x } else { y }  // ✅ OK
}
<span class="boring">}</span></code></pre></pre>
<h3 id="structs-with-lifetimes"><a class="header" href="#structs-with-lifetimes">Structs with Lifetimes</a></h3>
<pre><pre class="playground"><code class="language-rust">// Struct holding references needs lifetime annotation
struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,  // This reference must live at least as long as the struct
}

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
    
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {}", announcement);
        self.part  // Returns reference with same lifetime as &amp;self
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    // i is valid as long as novel is valid
}</code></pre></pre>
<h3 id="static-lifetime"><a class="header" href="#static-lifetime">Static Lifetime</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 'static means the reference lives for the entire program duration
let s: &amp;'static str = "I have a static lifetime.";  // String literals

// Static variables
static GLOBAL_COUNT: i32 = 0;
let count_ref: &amp;'static i32 = &amp;GLOBAL_COUNT;

// Sometimes you need to store static references
struct Config {
    name: &amp;'static str,    // Must be a string literal or static
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="advanced-ownership-patterns"><a class="header" href="#advanced-ownership-patterns">Advanced Ownership Patterns</a></h2>
<h3 id="returning-references-from-functions"><a class="header" href="#returning-references-from-functions">Returning References from Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Cannot return reference to local variable
fn create_and_return() -&gt; &amp;str {
    let s = String::from("hello");
    &amp;s  // Error: does not live long enough
}

// ✅ Return owned value instead
fn create_and_return_owned() -&gt; String {
    String::from("hello")
}

// ✅ Return reference to input (with lifetime)
fn get_first_word(text: &amp;str) -&gt; &amp;str {
    text.split_whitespace().next().unwrap_or("")
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ownership-with-collections"><a class="header" href="#ownership-with-collections">Ownership with Collections</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    
    // Adding owned values
    vec.push(String::from("hello"));
    vec.push(String::from("world"));
    
    // ❌ Cannot move out of vector by index
    // let first = vec[0];  // Error: cannot move
    
    // ✅ Borrowing is fine
    let first_ref = &amp;vec[0];
    println!("First: {}", first_ref);
    
    // ✅ Clone if you need ownership
    let first_owned = vec[0].clone();
    
    // ✅ Or use into_iter() to transfer ownership
    for item in vec {  // vec is moved here
        println!("Owned item: {}", item);
    }
    // vec is no longer usable
}</code></pre></pre>
<h3 id="splitting-borrows"><a class="header" href="#splitting-borrows">Splitting Borrows</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sometimes you need to borrow different parts of a struct
struct Point {
    x: f64,
    y: f64,
}

impl Point {
    // ❌ This won't work - can't return multiple mutable references
    // fn get_coords_mut(&amp;mut self) -&gt; (&amp;mut f64, &amp;mut f64) {
    //     (&amp;mut self.x, &amp;mut self.y)
    // }
    
    // ✅ This works - different fields can be borrowed separately
    fn update_coords(&amp;mut self, new_x: f64, new_y: f64) {
        self.x = new_x;  // Borrow x mutably
        self.y = new_y;  // Borrow y mutably (different field)
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="common-ownership-patterns-and-solutions"><a class="header" href="#common-ownership-patterns-and-solutions">Common Ownership Patterns and Solutions</a></h2>
<h3 id="pattern-1-function-parameters"><a class="header" href="#pattern-1-function-parameters">Pattern 1: Function Parameters</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Don't take ownership unless you need it
fn process_text(text: String) -&gt; usize {
    text.len()  // We don't need to own text for this
}

// ✅ Better: take a reference
fn process_text(text: &amp;str) -&gt; usize {
    text.len()
}

// ✅ When you do need ownership:
fn store_text(text: String) -&gt; Box&lt;String&gt; {
    Box::new(text)  // We're storing it, so ownership makes sense
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-return-values"><a class="header" href="#pattern-2-return-values">Pattern 2: Return Values</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Return owned values when creating new data
fn create_greeting(name: &amp;str) -&gt; String {
    format!("Hello, {}!", name)
}

// ✅ Return references when extracting from input
fn get_file_extension(filename: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    filename.split('.').last()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-structs-holding-data"><a class="header" href="#pattern-3-structs-holding-data">Pattern 3: Structs Holding Data</a></h3>
<pre><pre class="playground"><code class="language-rust">// ✅ Own data when struct should control lifetime
#[derive(Debug)]
struct User {
    name: String,      // Owned
    email: String,     // Owned
}

// ✅ Borrow when data lives elsewhere  
#[derive(Debug)]
struct UserRef&lt;'a&gt; {
    name: &amp;'a str,     // Borrowed
    email: &amp;'a str,    // Borrowed
}

// Usage
fn main() {
    // Owned version - can outlive source data
    let user = User {
        name: String::from("Alice"),
        email: String::from("alice@example.com"),
    };
    
    // Borrowed version - tied to source data lifetime
    let name = "Bob";
    let email = "bob@example.com";
    let user_ref = UserRef { name, email };
}</code></pre></pre>
<hr />
<h2 id="debugging-ownership-errors"><a class="header" href="#debugging-ownership-errors">Debugging Ownership Errors</a></h2>
<h3 id="common-error-messages-and-solutions"><a class="header" href="#common-error-messages-and-solutions">Common Error Messages and Solutions</a></h3>
<p><strong>1. “Value borrowed after move”</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Problem
let s = String::from("hello");
let s2 = s;           // s moved here
println!("{}", s);    // Error: value borrowed after move

// ✅ Solutions
// Option 1: Use references
let s = String::from("hello");
let s2 = &amp;s;          // Borrow instead
println!("{} {}", s, s2);

// Option 2: Clone when you need copies
let s = String::from("hello");
let s2 = s.clone();   // Explicit copy
println!("{} {}", s, s2);
<span class="boring">}</span></code></pre></pre>
<p><strong>2. “Cannot borrow as mutable”</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Problem
let s = String::from("hello");  // Immutable
s.push_str(" world");          // Error: cannot borrow as mutable

// ✅ Solution: Make it mutable
let mut s = String::from("hello");
s.push_str(" world");
<span class="boring">}</span></code></pre></pre>
<p><strong>3. “Borrowed value does not live long enough”</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Problem
fn get_string() -&gt; &amp;str {
    let s = String::from("hello");
    &amp;s  // Error: does not live long enough
}

// ✅ Solutions
// Option 1: Return owned value
fn get_string() -&gt; String {
    String::from("hello")
}

// Option 2: Use string literal (static lifetime)
fn get_string() -&gt; &amp;'static str {
    "hello"
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tools-for-understanding-ownership"><a class="header" href="#tools-for-understanding-ownership">Tools for Understanding Ownership</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_ownership() {
    let s1 = String::from("hello");
    println!("s1 created");
    
    let s2 = s1;  // Move occurs here
    println!("s1 moved to s2");
    // println!("{}", s1);  // This would error
    
    let s3 = &amp;s2;  // Borrow s2
    println!("s2 borrowed as s3: {}", s3);
    
    drop(s2);  // Explicit drop
    println!("s2 dropped");
    // println!("{}", s3);  // This would error - s2 was dropped
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-implications"><a class="header" href="#performance-implications">Performance Implications</a></h2>
<h3 id="zero-cost-abstractions"><a class="header" href="#zero-cost-abstractions">Zero-Cost Abstractions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All of these have the same runtime performance:

// Direct access
let vec = vec![1, 2, 3, 4, 5];
let sum1 = vec[0] + vec[1] + vec[2] + vec[3] + vec[4];

// Iterator (zero-cost abstraction)
let sum2: i32 = vec.iter().sum();

// Reference passing (no copying)
fn sum_vec(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    v.iter().sum()
}
let sum3 = sum_vec(&amp;vec);

// All compile to similar assembly code!
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-layout-guarantees"><a class="header" href="#memory-layout-guarantees">Memory Layout Guarantees</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust guarantees memory layout
#[repr(C)]  // Compatible with C struct layout
struct Point {
    x: f64,     // Guaranteed to be first
    y: f64,     // Guaranteed to be second
}

// No hidden vtables, no GC headers
// What you see is what you get in memory
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li><strong>Ownership prevents entire classes of bugs</strong> at compile time</li>
<li><strong>Move semantics are default</strong> - be explicit when you want copies</li>
<li><strong>Borrowing allows safe sharing</strong> without ownership transfer</li>
<li><strong>Lifetimes ensure references are always valid</strong> but often inferred</li>
<li><strong>The compiler is your friend</strong> - ownership errors are caught early</li>
<li><strong>Zero runtime cost</strong> - all ownership checks happen at compile time</li>
</ol>
<h3 id="mental-model-summary"><a class="header" href="#mental-model-summary">Mental Model Summary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Think of ownership like keys to a house:
let house_keys = String::from("keys");        // You own the keys

let friend = house_keys;                      // You give keys to friend
// house_keys is no longer valid             // You no longer have keys

let borrowed_keys = &amp;friend;                  // Friend lets you borrow keys
// friend still owns keys                     // Friend still owns them

drop(friend);                                 // Friend moves away
// borrowed_keys no longer valid             // Your borrowed keys invalid
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="exercise-1-ownership-transfer-chain"><a class="header" href="#exercise-1-ownership-transfer-chain">Exercise 1: Ownership Transfer Chain</a></h3>
<p>Create a program that demonstrates ownership transfer through a chain of functions:</p>
<pre><pre class="playground"><code class="language-rust">// Implement these functions following ownership rules
fn create_message() -&gt; String {
    // Create and return a String
}

fn add_greeting(message: String) -&gt; String {
    // Take ownership, add "Hello, " prefix, return new String
}

fn add_punctuation(message: String) -&gt; String {
    // Take ownership, add "!" suffix, return new String
}

fn print_and_consume(message: String) {
    // Take ownership, print message, let it be dropped
}

fn main() {
    // Chain the functions together
    // create -&gt; add_greeting -&gt; add_punctuation -&gt; print_and_consume
    
    // Try to use the message after each step - what happens?
}</code></pre></pre>
<h3 id="exercise-2-reference-vs-ownership"><a class="header" href="#exercise-2-reference-vs-ownership">Exercise 2: Reference vs Ownership</a></h3>
<p>Fix the ownership issues in this code:</p>
<pre><pre class="playground"><code class="language-rust">fn analyze_text(text: String) -&gt; (usize, String) {
    let word_count = text.split_whitespace().count();
    let uppercase = text.to_uppercase();
    (word_count, uppercase)
}

fn main() {
    let article = String::from("Rust is a systems programming language");
    
    let (count, upper) = analyze_text(article);
    
    println!("Original: {}", article);  // ❌ This should work but doesn't
    println!("Word count: {}", count);
    println!("Uppercase: {}", upper);
    
    // Also make this work:
    let count2 = analyze_text(article).0;  // ❌ This should also work
}</code></pre></pre>
<h3 id="exercise-3-lifetime-annotations"><a class="header" href="#exercise-3-lifetime-annotations">Exercise 3: Lifetime Annotations</a></h3>
<p>Implement a function that finds the longest common prefix of two strings:</p>
<pre><pre class="playground"><code class="language-rust">// Fix the lifetime annotations
fn longest_common_prefix(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {
    let mut i = 0;
    let s1_chars: Vec&lt;char&gt; = s1.chars().collect();
    let s2_chars: Vec&lt;char&gt; = s2.chars().collect();
    
    while i &lt; s1_chars.len() &amp;&amp; 
          i &lt; s2_chars.len() &amp;&amp; 
          s1_chars[i] == s2_chars[i] {
        i += 1;
    }
    
    &amp;s1[..i]  // Return slice of first string
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_common_prefix() {
        assert_eq!(longest_common_prefix("hello", "help"), "hel");
        assert_eq!(longest_common_prefix("rust", "ruby"), "ru");
        assert_eq!(longest_common_prefix("abc", "xyz"), "");
    }
}

fn main() {
    let word1 = String::from("programming");
    let word2 = "program";
    
    let prefix = longest_common_prefix(&amp;word1, word2);
    println!("Common prefix: '{}'", prefix);
    
    // Both word1 and word2 should still be usable here
    println!("Word1: {}, Word2: {}", word1, word2);
}</code></pre></pre>
<p><strong>Next Up:</strong> In Chapter 5, we’ll explore smart pointers - Rust’s tools for more complex memory management scenarios when simple ownership isn’t enough.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day1/03_structs_enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day1/05_smart_pointers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day1/03_structs_enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day1/05_smart_pointers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
