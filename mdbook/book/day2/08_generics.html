<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generics &amp; Type Safety - Rust Course 2025</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Interactive Rust programming course built with mdBook">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Course 2025</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18/edit/main/mdbook/src/day2/08_generics.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-8-generics--type-safety"><a class="header" href="#chapter-8-generics--type-safety">Chapter 8: Generics &amp; Type Safety</a></h1>
<h2 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h2>
<ul>
<li>Master generic functions, structs, and methods</li>
<li>Understand trait bounds and where clauses</li>
<li>Learn const generics for compile-time parameters</li>
<li>Apply type-driven design patterns</li>
<li>Compare with C++ templates and .NET generics</li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Generics allow you to write flexible, reusable code that works with multiple types while maintaining type safety. Coming from C++ or .NET, you’ll find Rust’s generics familiar but more constrained—in a good way.</p>
<h2 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h2>
<h3 id="basic-generic-functions"><a class="header" href="#basic-generic-functions">Basic Generic Functions</a></h3>
<pre><pre class="playground"><code class="language-rust">// Generic function that works with any type T
fn swap&lt;T&gt;(a: &amp;mut T, b: &amp;mut T) {
    std::mem::swap(a, b);
}

// Multiple generic parameters
fn pair&lt;T, U&gt;(first: T, second: U) -&gt; (T, U) {
    (first, second)
}

// Usage
fn main() {
    let mut x = 5;
    let mut y = 10;
    swap(&amp;mut x, &amp;mut y);
    println!("x: {}, y: {}", x, y); // x: 10, y: 5
    
    let p = pair("hello", 42);
    println!("{:?}", p); // ("hello", 42)
}</code></pre></pre>
<h3 id="comparison-with-c-and-net"><a class="header" href="#comparison-with-c-and-net">Comparison with C++ and .NET</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Rust</th><th>C++ Templates</th><th>.NET Generics</th></tr></thead><tbody>
<tr><td>Compilation</td><td>Monomorphization</td><td>Template instantiation</td><td>Runtime generics</td></tr>
<tr><td>Type checking</td><td>At definition</td><td>At instantiation</td><td>At definition</td></tr>
<tr><td>Constraints</td><td>Trait bounds</td><td>Concepts (C++20)</td><td>Where clauses</td></tr>
<tr><td>Code bloat</td><td>Yes (like C++)</td><td>Yes</td><td>No</td></tr>
<tr><td>Performance</td><td>Zero-cost</td><td>Zero-cost</td><td>Small overhead</td></tr>
</tbody></table>
</div>
<h2 id="generic-structs"><a class="header" href="#generic-structs">Generic Structs</a></h2>
<pre><pre class="playground"><code class="language-rust">// Generic struct
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

// Different types for each field
struct Pair&lt;T, U&gt; {
    first: T,
    second: U,
}

// Implementation for generic struct
impl&lt;T&gt; Point&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Point { x, y }
    }
}

// Implementation for specific type
impl Point&lt;f64&gt; {
    fn distance_from_origin(&amp;self) -&gt; f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let integer_point = Point::new(5, 10);
    let float_point = Point::new(1.0, 4.0);
    
    // Only available for Point&lt;f64&gt;
    println!("Distance: {}", float_point.distance_from_origin());
}</code></pre></pre>
<h2 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h2>
<p>Trait bounds specify what functionality a generic type must have.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

// T must implement Display
fn print_it&lt;T: Display&gt;(value: T) {
    println!("{}", value);
}

// Multiple bounds with +
fn print_and_clone&lt;T: Display + Clone&gt;(value: T) -&gt; T {
    println!("{}", value);
    value.clone()
}

// Trait bounds on structs
struct Wrapper&lt;T: Display&gt; {
    value: T,
}

// Complex bounds
fn complex_function&lt;T, U&gt;(t: T, u: U) -&gt; String
where
    T: Display + Clone,
    U: Display + Debug,
{
    format!("{} and {:?}", t.clone(), u)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="where-clauses"><a class="header" href="#where-clauses">Where Clauses</a></h2>
<p>Where clauses make complex bounds more readable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

// Instead of this...
fn ugly&lt;T: Display + Clone, U: Debug + Display&gt;(t: T, u: U) {
    // ...
}

// Write this...
fn pretty&lt;T, U&gt;(t: T, u: U)
where
    T: Display + Clone,
    U: Debug + Display,
{
    // Much cleaner!
}

// Particularly useful with associated types
fn process&lt;I&gt;(iter: I)
where
    I: Iterator,
    I::Item: Display,
{
    for item in iter {
        println!("{}", item);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="generic-enums"><a class="header" href="#generic-enums">Generic Enums</a></h2>
<p>The most common generic enums you’ll use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Option&lt;T&gt; - Rust's null replacement
enum Option&lt;T&gt; {
    Some(T),
    None,
}

// Result&lt;T, E&gt; - For error handling
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

// Custom generic enum
enum BinaryTree&lt;T&gt; {
    Empty,
    Node {
        value: T,
        left: Box&lt;BinaryTree&lt;T&gt;&gt;,
        right: Box&lt;BinaryTree&lt;T&gt;&gt;,
    },
}

impl&lt;T&gt; BinaryTree&lt;T&gt; {
    fn new() -&gt; Self {
        BinaryTree::Empty
    }
    
    fn insert(&amp;mut self, value: T) 
    where 
        T: Ord,
    {
        // Implementation here
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="const-generics"><a class="header" href="#const-generics">Const Generics</a></h2>
<p>Const generics allow you to parameterize types with constant values:</p>
<pre><pre class="playground"><code class="language-rust">// Array wrapper with compile-time size
struct ArrayWrapper&lt;T, const N: usize&gt; {
    data: [T; N],
}

impl&lt;T, const N: usize&gt; ArrayWrapper&lt;T, N&gt; {
    fn new(value: T) -&gt; Self
    where
        T: Copy,
    {
        ArrayWrapper {
            data: [value; N],
        }
    }
}

// Matrix type with compile-time dimensions
struct Matrix&lt;T, const ROWS: usize, const COLS: usize&gt; {
    data: [[T; COLS]; ROWS],
}

fn main() {
    let arr: ArrayWrapper&lt;i32, 5&gt; = ArrayWrapper::new(0);
    let matrix: Matrix&lt;f64, 3, 4&gt; = Matrix {
        data: [[0.0; 4]; 3],
    };
}</code></pre></pre>
<h2 id="type-aliases-and-newtype-pattern"><a class="header" href="#type-aliases-and-newtype-pattern">Type Aliases and Newtype Pattern</a></h2>
<pre><pre class="playground"><code class="language-rust">// Type alias - just a synonym
type Kilometers = i32;
type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;

// Newtype pattern - creates a distinct type
struct Meters(f64);
struct Seconds(f64);

impl Meters {
    fn to_feet(&amp;self) -&gt; f64 {
        self.0 * 3.28084
    }
}

// Prevents mixing units
fn calculate_speed(distance: Meters, time: Seconds) -&gt; f64 {
    distance.0 / time.0
}

fn main() {
    let distance = Meters(100.0);
    let time = Seconds(9.58);
    
    // Type safety prevents this:
    // let wrong = calculate_speed(time, distance); // Error!
    
    let speed = calculate_speed(distance, time);
    println!("Speed: {} m/s", speed);
}</code></pre></pre>
<h2 id="phantom-types"><a class="header" href="#phantom-types">Phantom Types</a></h2>
<p>Phantom types provide compile-time guarantees without runtime cost:</p>
<pre><pre class="playground"><code class="language-rust">use std::marker::PhantomData;

// States for a type-safe builder
struct Locked;
struct Unlocked;

struct Door&lt;State&gt; {
    name: String,
    _state: PhantomData&lt;State&gt;,
}

impl Door&lt;Locked&gt; {
    fn new(name: String) -&gt; Self {
        Door {
            name,
            _state: PhantomData,
        }
    }
    
    fn unlock(self) -&gt; Door&lt;Unlocked&gt; {
        Door {
            name: self.name,
            _state: PhantomData,
        }
    }
}

impl Door&lt;Unlocked&gt; {
    fn open(&amp;self) {
        println!("Opening door: {}", self.name);
    }
    
    fn lock(self) -&gt; Door&lt;Locked&gt; {
        Door {
            name: self.name,
            _state: PhantomData,
        }
    }
}

fn main() {
    let door = Door::&lt;Locked&gt;::new("Front".to_string());
    // door.open(); // Error: method not found
    
    let door = door.unlock();
    door.open(); // OK
}</code></pre></pre>
<h2 id="advanced-pattern-type-driven-design"><a class="header" href="#advanced-pattern-type-driven-design">Advanced Pattern: Type-Driven Design</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Email validation at compile time
struct Unvalidated;
struct Validated;

struct Email&lt;State = Unvalidated&gt; {
    value: String,
    _state: PhantomData&lt;State&gt;,
}

impl Email&lt;Unvalidated&gt; {
    fn new(value: String) -&gt; Self {
        Email {
            value,
            _state: PhantomData,
        }
    }
    
    fn validate(self) -&gt; Result&lt;Email&lt;Validated&gt;, String&gt; {
        if self.value.contains('@') {
            Ok(Email {
                value: self.value,
                _state: PhantomData,
            })
        } else {
            Err("Invalid email".to_string())
        }
    }
}

impl Email&lt;Validated&gt; {
    fn send(&amp;self) {
        println!("Sending email to: {}", self.value);
    }
}

// Function that only accepts validated emails
fn send_newsletter(email: &amp;Email&lt;Validated&gt;) {
    email.send();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="1-over-constraining-generics"><a class="header" href="#1-over-constraining-generics">1. Over-constraining Generics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: unnecessary Clone bound
fn bad&lt;T: Clone + Display&gt;(value: &amp;T) {
    println!("{}", value); // Clone not needed!
}

// Good: only required bounds
fn good&lt;T: Display&gt;(value: &amp;T) {
    println!("{}", value);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-missing-lifetime-parameters"><a class="header" href="#2-missing-lifetime-parameters">2. Missing Lifetime Parameters</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Won't compile
// struct RefHolder&lt;T&gt; {
//     value: &amp;T,
// }

// Correct
struct RefHolder&lt;'a, T&gt; {
    value: &amp;'a T,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-monomorphization-bloat"><a class="header" href="#3-monomorphization-bloat">3. Monomorphization Bloat</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Each T creates a new function copy
fn generic&lt;T&gt;(value: T) -&gt; T {
    value
}

// Consider using trait objects for large functions
fn with_trait_object(value: &amp;dyn Display) {
    println!("{}", value);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="exercise-generic-priority-queue-with-constraints"><a class="header" href="#exercise-generic-priority-queue-with-constraints">Exercise: Generic Priority Queue with Constraints</a></h2>
<p>Create a priority queue system that demonstrates multiple generic programming concepts:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::{Debug, Display};
use std::cmp::Ord;
use std::marker::PhantomData;

// Part 1: Basic generic queue with trait bounds
#[derive(Debug)]
struct PriorityQueue&lt;T&gt;
where
    T: Ord + Debug,
{
    items: Vec&lt;T&gt;,
}

impl&lt;T&gt; PriorityQueue&lt;T&gt;
where
    T: Ord + Debug,
{
    fn new() -&gt; Self {
        // TODO: Create a new empty priority queue
        todo!()
    }

    fn enqueue(&amp;mut self, item: T) {
        // TODO: Add item and maintain sorted order (highest priority first)
        // Hint: Use Vec::push() then Vec::sort()
        todo!()
    }

    fn dequeue(&amp;mut self) -&gt; Option&lt;T&gt; {
        // TODO: Remove and return the highest priority item
        // Hint: Use Vec::pop() since we keep items sorted
        todo!()
    }

    fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        // TODO: Return reference to highest priority item without removing it
        todo!()
    }

    fn len(&amp;self) -&gt; usize {
        self.items.len()
    }

    fn is_empty(&amp;self) -&gt; bool {
        self.items.is_empty()
    }
}

// Part 2: Generic trait for items that can be prioritized
trait Prioritized {
    type Priority: Ord;

    fn priority(&amp;self) -&gt; Self::Priority;
}

// Part 3: Advanced queue that works with any Prioritized type
struct AdvancedQueue&lt;T&gt;
where
    T: Prioritized + Debug,
{
    items: Vec&lt;T&gt;,
}

impl&lt;T&gt; AdvancedQueue&lt;T&gt;
where
    T: Prioritized + Debug,
{
    fn new() -&gt; Self {
        AdvancedQueue { items: Vec::new() }
    }

    fn enqueue(&amp;mut self, item: T) {
        // TODO: Insert item in correct position based on priority
        // Use binary search for efficient insertion
        todo!()
    }

    fn dequeue(&amp;mut self) -&gt; Option&lt;T&gt; {
        // TODO: Remove highest priority item
        todo!()
    }
}

// Part 4: Example types implementing Prioritized
#[derive(Debug, Eq, PartialEq)]
struct Task {
    name: String,
    urgency: u32,
}

impl Prioritized for Task {
    type Priority = u32;

    fn priority(&amp;self) -&gt; Self::Priority {
        // TODO: Return the urgency level
        todo!()
    }
}

impl Ord for Task {
    fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering {
        // TODO: Compare based on urgency (higher urgency = higher priority)
        todo!()
    }
}

impl PartialOrd for Task {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
        Some(self.cmp(other))
    }
}

// Part 5: Generic function with multiple trait bounds
fn process_queue&lt;T, Q&gt;(queue: &amp;mut Q, max_items: usize) -&gt; Vec&lt;T&gt;
where
    T: Debug + Clone,
    Q: QueueOperations&lt;T&gt;,
{
    // TODO: Process up to max_items from the queue
    // Return a vector of processed items
    todo!()
}

// Part 6: Trait for queue operations (demonstrates trait design)
trait QueueOperations&lt;T&gt; {
    fn enqueue(&amp;mut self, item: T);
    fn dequeue(&amp;mut self) -&gt; Option&lt;T&gt;;
    fn len(&amp;self) -&gt; usize;
}

// TODO: Implement QueueOperations for PriorityQueue&lt;T&gt;

fn main() {
    // Test basic priority queue with numbers
    let mut num_queue = PriorityQueue::new();
    num_queue.enqueue(5);
    num_queue.enqueue(1);
    num_queue.enqueue(10);
    num_queue.enqueue(3);

    println!("Number queue:");
    while let Some(num) = num_queue.dequeue() {
        println!("Processing: {}", num);
    }

    // Test with custom Task type
    let mut task_queue = PriorityQueue::new();
    task_queue.enqueue(Task { name: "Low".to_string(), urgency: 1 });
    task_queue.enqueue(Task { name: "High".to_string(), urgency: 5 });
    task_queue.enqueue(Task { name: "Medium".to_string(), urgency: 3 });

    println!("\nTask queue:");
    while let Some(task) = task_queue.dequeue() {
        println!("Processing: {:?}", task);
    }

    // Test advanced queue with Prioritized trait
    let mut advanced_queue = AdvancedQueue::new();
    advanced_queue.enqueue(Task { name: "First".to_string(), urgency: 2 });
    advanced_queue.enqueue(Task { name: "Second".to_string(), urgency: 4 });

    println!("\nAdvanced queue:");
    while let Some(task) = advanced_queue.dequeue() {
        println!("Processing: {:?}", task);
    }
}</code></pre></pre>
<p><strong>Implementation Guidelines:</strong></p>
<ol>
<li>
<p><strong>PriorityQueue methods:</strong></p>
<ul>
<li><code>new()</code>: Return <code>PriorityQueue { items: Vec::new() }</code></li>
<li><code>enqueue()</code>: Push item then sort with <code>self.items.sort()</code></li>
<li><code>dequeue()</code>: Use <code>self.items.pop()</code> (gets highest after sorting)</li>
<li><code>peek()</code>: Use <code>self.items.last()</code></li>
</ul>
</li>
<li>
<p><strong>Task::priority():</strong></p>
<ul>
<li>Return <code>self.urgency</code></li>
</ul>
</li>
<li>
<p><strong>Task::cmp():</strong></p>
<ul>
<li>Use <code>self.urgency.cmp(&amp;other.urgency)</code></li>
</ul>
</li>
<li>
<p><strong>AdvancedQueue::enqueue():</strong></p>
<ul>
<li>Use <code>binary_search_by_key()</code> to find insertion point</li>
<li>Use <code>insert()</code> to maintain sorted order</li>
</ul>
</li>
<li>
<p><strong>QueueOperations trait implementation:</strong></p>
<ul>
<li>Implement for <code>PriorityQueue&lt;T&gt;</code> by delegating to existing methods</li>
</ul>
</li>
</ol>
<p><strong>What this exercise teaches:</strong></p>
<ul>
<li><strong>Trait bounds</strong> (<code>Ord + Debug</code>) restrict generic types</li>
<li><strong>Associated types</strong> in traits (<code>Priority</code>)</li>
<li><strong>Complex where clauses</strong> for readable constraints</li>
<li><strong>Generic trait implementation</strong> with multiple bounds</li>
<li><strong>Real-world generic patterns</strong> beyond simple containers</li>
<li><strong>Trait design</strong> for abstraction over different implementations</li>
</ul>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>✅ <strong>Generics provide type safety without code duplication</strong> - Write once, use with many types</p>
<p>✅ <strong>Trait bounds specify required functionality</strong> - More explicit than C++ templates</p>
<p>✅ <strong>Monomorphization means zero runtime cost</strong> - Like C++ templates, unlike .NET generics</p>
<p>✅ <strong>Const generics enable compile-time computations</strong> - Arrays and matrices with known sizes</p>
<p>✅ <strong>Phantom types provide compile-time guarantees</strong> - State machines in the type system</p>
<p>✅ <strong>Type-driven design prevents bugs at compile time</strong> - Invalid states are unrepresentable</p>
<hr />
<p>Next: <a href="./09_pattern_matching.html">Chapter 9: Enums &amp; Pattern Matching</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day2/07_traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day2/09_pattern_matching.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day2/07_traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day2/09_pattern_matching.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
