<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Enums &amp; Pattern Matching - Rust Course 2025</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Interactive Rust programming course built with mdBook">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Course 2025</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/bar9/rust-course-2025-09-18/edit/main/mdbook/src/day2/09_pattern_matching.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-9-pattern-matching---exhaustive-control-flow"><a class="header" href="#chapter-9-pattern-matching---exhaustive-control-flow">Chapter 9: Pattern Matching - Exhaustive Control Flow</a></h1>
<h2 id="advanced-pattern-matching-optionresult-handling-and-match-guards"><a class="header" href="#advanced-pattern-matching-optionresult-handling-and-match-guards">Advanced Pattern Matching, Option/Result Handling, and Match Guards</a></h2>
<h3 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h3>
<p>By the end of this chapter, you’ll be able to:</p>
<ul>
<li>Use exhaustive pattern matching to handle all possible cases</li>
<li>Apply advanced patterns with destructuring and guards</li>
<li>Handle Option and Result types idiomatically</li>
<li>Use if let, while let for conditional pattern matching</li>
<li>Understand when to use match vs if let vs pattern matching in function parameters</li>
<li>Write robust error handling with pattern matching</li>
<li>Apply match guards for complex conditional logic</li>
</ul>
<hr />
<h2 id="pattern-matching-vs-switch-statements"><a class="header" href="#pattern-matching-vs-switch-statements">Pattern Matching vs Switch Statements</a></h2>
<h3 id="comparison-with-other-languages"><a class="header" href="#comparison-with-other-languages">Comparison with Other Languages</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>C/C++ switch</th><th>C# switch</th><th>Rust match</th></tr></thead><tbody>
<tr><td>Exhaustiveness</td><td>No</td><td>Partial (warnings)</td><td>Yes (enforced)</td></tr>
<tr><td>Complex patterns</td><td>No</td><td>Limited</td><td>Full destructuring</td></tr>
<tr><td>Guards</td><td>No</td><td>Limited (when)</td><td>Yes</td></tr>
<tr><td>Return values</td><td>No</td><td>Expression (C# 8+)</td><td>Always expression</td></tr>
<tr><td>Fall-through</td><td>Default (dangerous)</td><td>No</td><td>Not possible</td></tr>
</tbody></table>
</div>
<h3 id="basic-match-expression"><a class="header" href="#basic-match-expression">Basic Match Expression</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum TrafficLight {
    Red,
    Yellow,
    Green,
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(u8, u8, u8),
}

fn handle_traffic_light(light: TrafficLight) -&gt; &amp;'static str {
    match light {
        TrafficLight::Red =&gt; "Stop",
        TrafficLight::Yellow =&gt; "Prepare to stop",
        TrafficLight::Green =&gt; "Go",
        // Compiler ensures all variants are handled!
    }
}

fn handle_message(msg: Message) {
    match msg {
        Message::Quit =&gt; {
            println!("Quit message received");
            std::process::exit(0);
        },
        Message::Move { x, y } =&gt; {
            println!("Move to coordinates: ({}, {})", x, y);
        },
        Message::Write(text) =&gt; {
            println!("Text message: {}", text);
        },
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change color to RGB({}, {}, {})", r, g, b);
        },
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="option-and-result-pattern-matching"><a class="header" href="#option-and-result-pattern-matching">Option and Result Pattern Matching</a></h2>
<h3 id="handling-option"><a class="header" href="#handling-option">Handling Option<T></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(x: f64, y: f64) -&gt; Option&lt;f64&gt; {
    if y != 0.0 {
        Some(x / y)
    } else {
        None
    }
}

fn process_division(x: f64, y: f64) {
    match divide(x, y) {
        Some(result) =&gt; println!("Result: {}", result),
        None =&gt; println!("Cannot divide by zero"),
    }
}

// Nested Option handling
fn parse_config(input: Option&lt;&amp;str&gt;) -&gt; Option&lt;u32&gt; {
    match input {
        Some(s) =&gt; match s.parse::&lt;u32&gt;() {
            Ok(num) =&gt; Some(num),
            Err(_) =&gt; None,
        },
        None =&gt; None,
    }
}

// Better with combinators (covered later)
fn parse_config_better(input: Option&lt;&amp;str&gt;) -&gt; Option&lt;u32&gt; {
    input?.parse().ok()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handling-resultt-e"><a class="header" href="#handling-resultt-e">Handling Result&lt;T, E&gt;</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_file_contents(filename: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let mut file = File::open(filename)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}

fn process_file(filename: &amp;str) {
    match read_file_contents(filename) {
        Ok(contents) =&gt; {
            println!("File contents ({} bytes):", contents.len());
            println!("{}", contents);
        },
        Err(error) =&gt; {
            match error.kind() {
                io::ErrorKind::NotFound =&gt; {
                    println!("File '{}' not found", filename);
                },
                io::ErrorKind::PermissionDenied =&gt; {
                    println!("Permission denied for file '{}'", filename);
                },
                _ =&gt; {
                    println!("Error reading file '{}': {}", filename, error);
                },
            }
        }
    }
}

// Custom error types
#[derive(Debug)]
enum ConfigError {
    MissingFile,
    ParseError(String),
    ValidationError(String),
}

fn load_config(path: &amp;str) -&gt; Result&lt;Config, ConfigError&gt; {
    let contents = std::fs::read_to_string(path)
        .map_err(|_| ConfigError::MissingFile)?;
    
    let config: Config = serde_json::from_str(&amp;contents)
        .map_err(|e| ConfigError::ParseError(e.to_string()))?;
    
    validate_config(&amp;config)
        .map_err(|msg| ConfigError::ValidationError(msg))?;
    
    Ok(config)
}

#[derive(Debug)]
struct Config {
    port: u16,
    host: String,
}

fn validate_config(config: &amp;Config) -&gt; Result&lt;(), String&gt; {
    if config.port == 0 {
        return Err("Port cannot be zero".to_string());
    }
    if config.host.is_empty() {
        return Err("Host cannot be empty".to_string());
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="destructuring-and-nested-patterns"><a class="header" href="#destructuring-and-nested-patterns">Destructuring and Nested Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

enum Shape {
    Circle { center: Point, radius: f64 },
    Rectangle { top_left: Point, bottom_right: Point },
    Triangle(Point, Point, Point),
}

fn analyze_shape(shape: &amp;Shape) {
    match shape {
        // Destructure nested structures
        Shape::Circle { center: Point { x, y }, radius } =&gt; {
            println!("Circle at ({}, {}) with radius {}", x, y, radius);
        },
        
        // Partial destructuring with ..
        Shape::Rectangle { top_left: Point { x: x1, y: y1 }, .. } =&gt; {
            println!("Rectangle starting at ({}, {})", x1, y1);
        },
        
        // Destructure tuple variants
        Shape::Triangle(p1, p2, p3) =&gt; {
            println!("Triangle with vertices: ({}, {}), ({}, {}), ({}, {})", 
                     p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
        },
    }
}

// Pattern matching with references and dereferencing
fn process_optional_point(point: &amp;Option&lt;Point&gt;) {
    match point {
        Some(Point { x, y }) =&gt; println!("Point at ({}, {})", x, y),
        None =&gt; println!("No point"),
    }
}

// Multiple patterns
fn classify_number(n: i32) -&gt; &amp;'static str {
    match n {
        1 | 2 | 3 =&gt; "small",
        4..=10 =&gt; "medium",
        11..=100 =&gt; "large",
        _ =&gt; "very large",
    }
}

// Binding values in patterns
fn process_message_advanced(msg: Message) {
    match msg {
        Message::Move { x: 0, y } =&gt; {
            println!("Move vertically to y: {}", y);
        },
        Message::Move { x, y: 0 } =&gt; {
            println!("Move horizontally to x: {}", x);
        },
        Message::Move { x, y } if x == y =&gt; {
            println!("Move diagonally to ({}, {})", x, y);
        },
        Message::Move { x, y } =&gt; {
            println!("Move to ({}, {})", x, y);
        },
        msg @ Message::Write(_) =&gt; {
            println!("Received write message: {:?}", msg);
        },
        _ =&gt; println!("Other message"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="match-guards"><a class="header" href="#match-guards">Match Guards</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn categorize_temperature(temp: f64, is_celsius: bool) -&gt; &amp;'static str {
    match temp {
        t if is_celsius &amp;&amp; t &lt; 0.0 =&gt; "freezing (Celsius)",
        t if is_celsius &amp;&amp; t &gt; 100.0 =&gt; "boiling (Celsius)",
        t if !is_celsius &amp;&amp; t &lt; 32.0 =&gt; "freezing (Fahrenheit)",
        t if !is_celsius &amp;&amp; t &gt; 212.0 =&gt; "boiling (Fahrenheit)",
        t if t &gt; 0.0 =&gt; "positive temperature",
        0.0 =&gt; "exactly zero",
        _ =&gt; "negative temperature",
    }
}

// Complex guards with destructuring
#[derive(Debug)]
enum Request {
    Get { path: String, authenticated: bool },
    Post { path: String, data: Vec&lt;u8&gt; },
}

fn handle_request(req: Request) -&gt; &amp;'static str {
    match req {
        Request::Get { path, authenticated: true } if path.starts_with("/admin") =&gt; {
            "Admin access granted"
        },
        Request::Get { path, authenticated: false } if path.starts_with("/admin") =&gt; {
            "Admin access denied"
        },
        Request::Get { .. } =&gt; "Regular GET request",
        Request::Post { data, .. } if data.len() &gt; 1024 =&gt; {
            "Large POST request"
        },
        Request::Post { .. } =&gt; "Regular POST request",
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="if-let-and-while-let"><a class="header" href="#if-let-and-while-let">if let and while let</a></h2>
<h3 id="if-let-for-simple-cases"><a class="header" href="#if-let-for-simple-cases">if let for Simple Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of verbose match
fn process_option_verbose(opt: Option&lt;i32&gt;) {
    match opt {
        Some(value) =&gt; println!("Got value: {}", value),
        None =&gt; {}, // Do nothing
    }
}

// Use if let for cleaner code
fn process_option_clean(opt: Option&lt;i32&gt;) {
    if let Some(value) = opt {
        println!("Got value: {}", value);
    }
}

// if let with else
fn process_result(result: Result&lt;String, &amp;str&gt;) {
    if let Ok(value) = result {
        println!("Success: {}", value);
    } else {
        println!("Something went wrong");
    }
}

// Chaining if let
fn process_nested(opt: Option&lt;Result&lt;i32, &amp;str&gt;&gt;) {
    if let Some(result) = opt {
        if let Ok(value) = result {
            println!("Got nested value: {}", value);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="while-let-for-loops"><a class="header" href="#while-let-for-loops">while let for Loops</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_iterator() {
    let mut stack = vec![1, 2, 3, 4, 5];
    
    // Pop elements while they exist
    while let Some(value) = stack.pop() {
        println!("Processing: {}", value);
    }
}

fn process_lines() {
    use std::io::{self, BufRead};
    
    let stdin = io::stdin();
    let mut lines = stdin.lock().lines();
    
    // Process lines until EOF or error
    while let Ok(line) = lines.next().unwrap_or(Err(io::Error::new(
        io::ErrorKind::UnexpectedEof, "EOF"
    ))) {
        if line.trim() == "quit" {
            break;
        }
        println!("You entered: {}", line);
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="pattern-matching-in-function-parameters"><a class="header" href="#pattern-matching-in-function-parameters">Pattern Matching in Function Parameters</a></h2>
<h3 id="destructuring-in-parameters"><a class="header" href="#destructuring-in-parameters">Destructuring in Parameters</a></h3>
<pre><pre class="playground"><code class="language-rust">// Destructure tuples in parameters
fn print_coordinates((x, y): (i32, i32)) {
    println!("Coordinates: ({}, {})", x, y);
}

// Destructure structs
fn print_point(Point { x, y }: Point) {
    println!("Point: ({}, {})", x, y);
}

// Destructure with references
fn analyze_point_ref(&amp;Point { x, y }: &amp;Point) {
    println!("Analyzing point at ({}, {})", x, y);
}

// Closure patterns
fn main() {
    let points = vec![
        Point { x: 1, y: 2 },
        Point { x: 3, y: 4 },
        Point { x: 5, y: 6 },
    ];
    
    // Destructure in closure parameters
    points.iter().for_each(|&amp;Point { x, y }| {
        println!("Point: ({}, {})", x, y);
    });
    
    // Filter with pattern matching
    let origin_points: Vec&lt;_&gt; = points
        .into_iter()
        .filter(|Point { x: 0, y: 0 }| true)  // Only points at origin
        .collect();
}</code></pre></pre>
<hr />
<h2 id="common-pitfalls-and-best-practices"><a class="header" href="#common-pitfalls-and-best-practices">Common Pitfalls and Best Practices</a></h2>
<h3 id="pitfall-1-incomplete-patterns"><a class="header" href="#pitfall-1-incomplete-patterns">Pitfall 1: Incomplete Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: This won't compile - missing Some case
fn bad_option_handling(opt: Option&lt;i32&gt;) {
    match opt {
        None =&gt; println!("Nothing"),
        // Error: non-exhaustive patterns
    }
}

// GOOD: Handle all cases
fn good_option_handling(opt: Option&lt;i32&gt;) {
    match opt {
        Some(val) =&gt; println!("Value: {}", val),
        None =&gt; println!("Nothing"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pitfall-2-unreachable-patterns"><a class="header" href="#pitfall-2-unreachable-patterns">Pitfall 2: Unreachable Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD: Unreachable pattern
fn bad_range_matching(n: i32) {
    match n {
        1..=10 =&gt; println!("Small"),
        5 =&gt; println!("Five"), // This is unreachable!
        _ =&gt; println!("Other"),
    }
}

// GOOD: More specific patterns first
fn good_range_matching(n: i32) {
    match n {
        5 =&gt; println!("Five"),
        1..=10 =&gt; println!("Small (not five)"),
        _ =&gt; println!("Other"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Use @ binding to capture while pattern matching
fn handle_special_ranges(value: i32) {
    match value {
        n @ 1..=5 =&gt; println!("Small number: {}", n),
        n @ 6..=10 =&gt; println!("Medium number: {}", n),
        n =&gt; println!("Large number: {}", n),
    }
}

// 2. Use .. to ignore fields you don't need
struct LargeStruct {
    important: i32,
    flag: bool,
    data1: String,
    data2: String,
    data3: Vec&lt;u8&gt;,
}

fn process_large_struct(s: LargeStruct) {
    match s {
        LargeStruct { important, flag: true, .. } =&gt; {
            println!("Important value with flag: {}", important);
        },
        LargeStruct { important, .. } =&gt; {
            println!("Important value without flag: {}", important);
        },
    }
}

// 3. Prefer early returns with guards
fn validate_user_input(input: &amp;str) -&gt; Result&lt;i32, &amp;'static str&gt; {
    match input.parse::&lt;i32&gt;() {
        Ok(n) if n &gt;= 0 =&gt; Ok(n),
        Ok(_) =&gt; Err("Number must be non-negative"),
        Err(_) =&gt; Err("Invalid number format"),
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="exercise-1-http-status-handler"><a class="header" href="#exercise-1-http-status-handler">Exercise 1: HTTP Status Handler</a></h3>
<p>Create a function that handles different HTTP status codes using pattern matching:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum HttpStatus {
    Ok,                    // 200
    NotFound,             // 404
    ServerError,          // 500
    Custom(u16),          // Any other code
}

#[derive(Debug)]
struct HttpResponse {
    status: HttpStatus,
    body: Option&lt;String&gt;,
    headers: Vec&lt;(String, String)&gt;,
}

// TODO: Implement this function
fn handle_response(response: HttpResponse) -&gt; String {
    // Pattern match on the response to return appropriate messages:
    // - Ok with body: "Success: {body}"
    // - Ok without body: "Success: No content"
    // - NotFound: "Error: Resource not found"
    // - ServerError: "Error: Internal server error"
    // - Custom(code) where code &lt; 400: "Info: Status {code}"
    // - Custom(code) where code &gt;= 400: "Error: Status {code}"
    todo!()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-2-configuration-parser"><a class="header" href="#exercise-2-configuration-parser">Exercise 2: Configuration Parser</a></h3>
<p>Parse a configuration string and handle various error cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum ConfigValue {
    String(String),
    Integer(i64),
    Boolean(bool),
    Array(Vec&lt;ConfigValue&gt;),
}

#[derive(Debug)]
enum ParseError {
    InvalidFormat,
    InvalidNumber(String),
    UnknownType,
}

// TODO: Implement this function
fn parse_config_line(line: &amp;str) -&gt; Result&lt;(String, ConfigValue), ParseError&gt; {
    // Parse lines in format: "key=value" or "key:type=value"
    // Supported types: string, int, bool, array
    // Examples:
    // - "name=John" -&gt; ("name", ConfigValue::String("John"))
    // - "port:int=8080" -&gt; ("port", ConfigValue::Integer(8080))
    // - "debug:bool=true" -&gt; ("debug", ConfigValue::Boolean(true))
    // - "tags:array=tag1,tag2,tag3" -&gt; ("tags", ConfigValue::Array([...]))
    
    todo!()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-3-state-machine"><a class="header" href="#exercise-3-state-machine">Exercise 3: State Machine</a></h3>
<p>Implement a simple state machine using pattern matching:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
enum State {
    Idle,
    Processing { progress: u8 },
    Error { message: String, recoverable: bool },
    Complete,
}

#[derive(Debug)]
enum Event {
    Start,
    Progress(u8),
    Error(String, bool),
    Reset,
    Finish,
}

// TODO: Implement state transitions
fn transition_state(current: State, event: Event) -&gt; State {
    // Implement these transitions:
    // - Idle + Start -&gt; Processing { progress: 0 }
    // - Processing + Progress(n) -&gt; Processing { progress: n }
    // - Processing + Finish -&gt; Complete
    // - Processing + Error(msg, recoverable) -&gt; Error { message: msg, recoverable }
    // - Error { recoverable: true, .. } + Reset -&gt; Idle
    // - Error { recoverable: false, .. } + Reset -&gt; Error (same state)
    // - Complete + Reset -&gt; Idle
    // - Any invalid transition keeps the current state
    
    todo!()
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li><strong>Exhaustiveness</strong> - Rust’s compiler ensures you handle all possible cases</li>
<li><strong>Pattern matching is an expression</strong> - Every match arm must return the same type</li>
<li><strong>Use if let</strong> for simple Option/Result handling instead of verbose match</li>
<li><strong>Match guards</strong> enable complex conditional logic within patterns</li>
<li><strong>Destructuring</strong> allows you to extract values from complex data structures</li>
<li><strong>Order matters</strong> - More specific patterns should come before general ones</li>
<li><strong>@ binding</strong> lets you capture values while pattern matching</li>
<li><strong>Early returns</strong> with guards can make code more readable</li>
</ol>
<p><strong>Next Up:</strong> In Chapter 10, we’ll explore error handling - Rust’s approach to robust error management with Result types and the ? operator.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../day2/08_generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../day2/10_error_handling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../day2/08_generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../day2/10_error_handling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
